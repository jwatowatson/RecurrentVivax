---
title: "Pooled Analysis"
author: "Aimee Taylor and James Watson"
output:
  html_document:
    df_print: paged
  html_notebook: default
  keep_md: TRUE
  pdf_document: default
---

# Preamble

Load R packages, functions and data.

```{r, echo=FALSE, include=FALSE}
#==========================================================================
# Set up
#==========================================================================
knitr::opts_chunk$set(cache = TRUE, cache.comments = FALSE, 
                      echo = TRUE, include = TRUE, 
                      fig.width = 7, fig.height = 7,
                      fig.pos = 'H', 
                      dev = 'png', dpi = 300)

require(dplyr) # For filter
require(gtools) # For permutations
require(tictoc) # For bdiag()
require(doParallel) # For post_prob_R
require(Matrix)
require(matrixStats) # for logSumExp
library(igraph) # For igraph
require(RColorBrewer)
load('../RData/TimingModel/MOD3_theta_estimates.RData')

source("../Genetic_Model/Data_functions.R")
source('../Genetic_Model/iGraph_functions.R')
source("../Genetic_Model/post_prob_CLI.R") 
source("../Genetic_Model/test_Rn_compatible.R") 
source("../Genetic_Model/Data_Inflation_Functions.R")

# The pooled MS data from BPD and VHX
load('../RData/GeneticModel/MS_data_PooledAnalysis.RData')

RUN_MODELS = TRUE
RUN_MODELS_CLUSTER = F
CREATE_PLOTS = T
```

Define the sets of microsatellite markers for the various datasets.

```{r}
MSs_VHX = c("PV.3.502","PV.3.27","PV.ms8","PV.1.501","PV.ms1","PV.ms5","PV.ms6")
MSs_all = c("PV.3.502","PV.3.27","PV.ms8","PV.1.501","PV.ms1","PV.ms5","PV.ms6",
            "PV.ms7","PV.ms16")
MSs_BPD = MSs_all
MSs_Main = c('PV.3.27', 'PV.3.502', 'PV.ms8') # These are typed for all episodes (the core group)
```

```{r}
#--------------------------------------------------------------------------
# Reformat the data s.t. there are no NA gaps in mixed infections
#--------------------------------------------------------------------------
MS_data_reformated = reformat_MSdata(MSdata = MS_pooled, MSs=MSs_all)
```


The approach is fully Bayesian and consists of the following:

* A prior probability vector for the recurrence state
* A likelihood based on the genetic data of being a *relapse*, a *recrudescence*, or a *reinfection* given the observed microsatellite data.

# Allele frequencies

There are a few ways of computing these. A natural first approach is to use the monoclonal data. However, some alleles are only seen in polyclonal infections, rending this approach not viable. A statistically rigorous approach would be to use a model for MS allele frequencies (e.g. Escalante 2015). At the moment we are using the empirical allele frequencies from the a specified dataset, with a Dirichlet-esque weight of 5 (5 pseudo-observations). 
Setting the weight to 0 recovers unweighted empirical allele frequencies. 

```{r, echo=F}
#--------------------------------------------------------------------------
# Estimate allele frequencies from reformated data ignoring NAs.

# Prior weight for the Dirichlet (setting weight to 0 recovers empirical freq):
MSs_all = c("PV.3.502","PV.3.27","PV.ms8",
            "PV.1.501","PV.ms1","PV.ms5",
            "PV.ms6", "PV.ms7","PV.ms16")

# These are motif lengths: for the plotting
MSs_Motifs = list("PV.3.502"=8,'PV.3.27' = 4, 
                  "PV.ms8" = 3, "PV.1.501"= 7, 
                  "PV.ms1" = 3, "PV.ms5" = 3,
                  "PV.ms6" = 3, "PV.ms16" =3,
                  "PV.ms7" = 3)

# This is an important parameter: pseudo weight in the Dirichlet prior
D_weight_Prior = 10

writeLines(paste('Number of episodes used to compute frequencies:',
                 sum(MS_pooled$Episode==1 & MS_pooled$MOI_id==1)))
Ind_Primary = which(MS_pooled$Episode==1)

# I wrote the following to check I understood - suggest as a more-readable alternative (agrees with ms text)
# Nice: have replaced the previous one
Fs_Combined =  apply(MS_pooled[,MSs_all], 2, function(x, Ind_Primary){
  # Extract xmax 
  xmax = max(x,na.rm=T)
  # prior parameter vector (iterpolates unobserved repeat lengths < xmax)
  param_vector = array(D_weight_Prior, dim = xmax, dimnames = list(1:xmax)) 
  # observed data summarised as counts
  obs_counts = table(x[Ind_Primary]) 
  # posterior parameter vector
  param_vector[names(obs_counts)] = param_vector[names(obs_counts)] + obs_counts
  # posterior mean
  posterior_mean = param_vector/sum(param_vector)
  return(posterior_mean)
})
```


## Plotting allele frequencies

These are the observed allele frequencies in the pooled data. We show 80% credible intervals (lo)

```{r AlleleFrequencies, echo=F}
if(CREATE_PLOTS){
  par(mfrow=c(3,3), las=1, bty='n', cex.axis=1.2)
  
  for(ms in MSs_all){ # As bars
    K = length(Fs_Combined[[ms]]) # Cardinality of ms 
    xs = rdirichlet(n = 1000, alpha = Fs_Combined[[ms]]) # Sample from posterior
    YMAX = max(apply(100*xs, 2, quantile, probs = .9)) # MC approximation of 0.9 percentile expressed as percentage
    N_MS = length(unique(MS_pooled$ID[MS_pooled$Episode==1 & !is.na(MS_pooled[,ms])])) # Number of observations
    plot(1:ncol(xs), rep(NA,K), 
         main = sprintf('%s (n = %s)', ms, N_MS), # sprintf so much easier :-)
         #main=paste(ms,' (n=',N_MS,')',sep = ''), 
         pch = 18, ylim=c(0,YMAX),col='red',
         ylab='%', xlab='', yaxt='n')
    abline(h=100/K)
    mtext(text = paste('Motif length:',MSs_Motifs[[ms]]),side = 1,line=3)
    for(k in 1:ncol(xs)){
      lines(rep(k,2), 100*quantile(xs[,k],probs = c(0.1,0.9)), col='blue')
    }
    points(1:length(Fs_Combined[[ms]]),
           100*Fs_Combined[[ms]],col='red',pch=18)
    
    axis(2, seq(0, round(YMAX), length.out = 3))
  }
}
```


# Computing the probability of relatedness across infections

The following iterates through each individual and computes the probability of relatedness states.

## Load the time-to-event priors

```{r}
inds = grepl('mean_theta', colnames(Mod3_ThetaEstimates)) # Extract mean
Episode_Identifier = Mod3_ThetaEstimates$Episode_Identifier
p = data.frame(Episode_Identifier = Episode_Identifier, Mod3_ThetaEstimates[,inds],
               stringsAsFactors = F) # Reformat
colnames(p) = c('Episode_Identifier', 'C', 'L', 'I')

genetic_AND_time_data_eps = intersect(p$Episode_Identifier, MS_data_reformated$Episode_Identifier)
p = p[p$Episode_Identifier %in% genetic_AND_time_data_eps,]
```


## Computation using full dataset 

We use all 9MS markers (when available).
```{r}
if(RUN_MODELS){
  #===============================================
  # Run new version (with time-to-event)
  #===============================================
  tic()
  thetas_9MS = post_prob_CLI(MS_data = MS_data_reformated, Fs = Fs_Combined, 
                             p = p, cores = 6, verbose = F) 
  thetas_9MS$Episode_Identifier = rownames(thetas_9MS)
  toc()
  
  #===============================================
  # Run new version (without time-to-event)
  #===============================================
  tic()
  thetas_9MS_Tagnostic = post_prob_CLI(MS_data = MS_data_reformated, Fs = Fs_Combined, 
                                       cores = 6, verbose = F)
  thetas_9MS_Tagnostic$Episode_Identifier = rownames(thetas_9MS_Tagnostic)
  toc()
}
```

# Plot results


These dataframes are sorted by episode number so the columns correspond between them. We make some data.frames that store the results for ease of plotting.

```{r}

thetas_9MS = arrange(thetas_9MS, Episode_Identifier)
thetas_9MS_Tagnostic = arrange(thetas_9MS_Tagnostic, Episode_Identifier)

Time_Estimates_1 = filter(Mod3_ThetaEstimates, 
                          Episode_Identifier %in% thetas_9MS$Episode_Identifier)
Time_Estimates_1 = arrange(Time_Estimates_1, Episode_Identifier)

thetas_9MS$drug = as.factor(Time_Estimates_1$arm_num)
# for plotting
thetas_9MS$drug_col = as.numeric(Time_Estimates_1$arm_num=='CHQ/PMQ')+1
thetas_9MS_Tagnostic$drug_col = as.numeric(Time_Estimates_1$arm_num=='CHQ/PMQ')+1

thetas_9MS_Tagnostic$drug = as.factor(Time_Estimates_1$arm_num)
```


## Going from time-to-event prior to posterior

There is some interesting correlation structure here - not quite sure what's happening exactly.
Have broken it down by radical cure and no radical cure, as that is quite a big piece of information!

```{r}
if(CREATE_PLOTS){
  par(mfrow=c(1,2),las=1, bty='n')
  # Time agnostic versus full posterior 
  plot(log10(thetas_9MS_Tagnostic$L), log10(thetas_9MS$L), 
       col=thetas_9MS$drug_col, main = 'Relapse',
       xlab = 'Time agnostic', ylab = 'Time included')
  lines(-10:0,-10:0)
  plot(log10(thetas_9MS_Tagnostic$I), log10(thetas_9MS$I), 
       col=thetas_9MS$drug_col, main = 'Reinfection',
       xlab = 'Time agnostic', ylab = 'Time included')
  lines(-20:0,-20:0)
  
  ##### Prior versusfull posterior
  plot(log10(Time_Estimates_1$Relapse_mean_theta),
       log10(thetas_9MS$L),main = 'Relapse',
       col=thetas_9MS$drug_col,
       xlab = 'Time based prior', ylab = 'Full posterior')
  lines(-10:10,-10:10)
  plot(log10(Time_Estimates_1$ReInfection_mean_theta),
       log10(thetas_9MS$I),main = 'Reinfection',
       col=thetas_9MS$drug_col,
       xlab = 'Time based prior', ylab = 'Full posterior')
  lines(-10:10,-10:10)
}
```

Probability of relapse, ordered from most to least likely:
```{r}
par(las=1, bty='n')
reLapse_ordered = sort.int(thetas_9MS$L, decreasing = TRUE, index.return = TRUE)
plot(reLapse_ordered$x, pch=18, col = thetas_9MS$drug_col[reLapse_ordered$ix],
     xlab = 'Recurrence index', ylab = 'Probability of relapse state',
     main = 'Full posterior: reLapse')
legend('topright',col = 1:2, legend = c('No PMQ','PMQ'),pch=19)

reLapse_ordered_Tagn = sort.int(thetas_9MS_Tagnostic$L, decreasing = TRUE, index.return = TRUE)
plot(reLapse_ordered_Tagn$x, pch=18, cex=.8,
     col = thetas_9MS_Tagnostic$drug_col[reLapse_ordered_Tagn$ix],
     xlab = 'Recurrence index', ylab = 'Probability of relapse state',
     main = 'Time agnostic posterior: reLapse')
legend('topright',col = 1:2, legend = c('No PMQ','PMQ'),pch=19)
```

Probability of reinfection, ordered from most to least likely:
```{r}
par(las=1, bty='n')
reinfection_ordered = sort.int(thetas_9MS$I, decreasing = TRUE, index.return = TRUE)
plot(reinfection_ordered$x, pch=18, col = thetas_9MS$drug_col[reinfection_ordered$ix],
     xlab = 'Recurrence index', ylab = 'Probability of reinfection state',
     main = 'Full posterior: reInfection')
legend('topright',col = 1:2, legend = c('No PMQ','PMQ'),pch=19)

reinfection_ordered_Tagn = sort.int(thetas_9MS_Tagnostic$I, decreasing = TRUE, index.return = TRUE)
plot(reinfection_ordered_Tagn$x, pch=18, cex=.8,
     col = thetas_9MS_Tagnostic$drug_col[reinfection_ordered_Tagn$ix],
     xlab = 'Recurrence index', ylab = 'Probability of reinfection state',
     main = 'Time agnostic posterior: reInfection')
legend('topright',col = 1:2, legend = c('No PMQ','PMQ'),pch=19)
```

Probability of recrudescence, ordered from most to least likely:
```{r}
par(las=1, bty='n')
recrud_ordered = sort.int(thetas_9MS$C, decreasing = TRUE, index.return = TRUE)
plot(recrud_ordered$x, pch=18, col = thetas_9MS$drug_col[recrud_ordered$ix],
     xlab = 'Recurrence index', ylab = 'Probability of recrudescence state',
     main = 'Full posterior: reCrudescence')
legend('topright',col = 1:2, legend = c('No PMQ','PMQ'),pch=19)

recrud_ordered_Tagn = sort.int(thetas_9MS_Tagnostic$C, decreasing = TRUE, index.return = TRUE)
plot(recrud_ordered_Tagn$x, pch=18, cex=.8,
     col = thetas_9MS_Tagnostic$drug_col[recrud_ordered_Tagn$ix],
     xlab = 'Recurrence index', ylab = 'Probability of recrudescence state',
     main = 'Time agnostic posterior: reCrudescence')
legend('topright',col = 1:2, legend = c('No PMQ','PMQ'),pch=19)
```

# Extra computations for VHX: too complex episodes

First we blow up the pooled analysis into all doubles
```{r}
MS_pooled_pairs = Inflate_into_pairs(MS_data = MS_pooled)
all_rec_eps = unique(MS_pooled_pairs$Episode_Identifier[MS_pooled_pairs$Episode==2])
P_matrix = data.frame(array(dim = c(length(all_rec_eps),4)))
colnames(P_matrix) = c('Episode_Identifier','C','I','L')
P_matrix$Episode_Identifier = all_rec_eps
for(ep in all_rec_eps){
  i = which(P_matrix$Episode_Identifier==ep)
  j = which(MS_pooled_pairs$Episode_Identifier==ep)[1]
  k = which(Mod3_ThetaEstimates$Episode_Identifier == paste(MS_pooled_pairs$ID_True[j],
                                                            MS_pooled_pairs$Second_EpNumber[j],
                                                            sep='_'))
  P_matrix[i,c('C','I','L')] = Mod3_ThetaEstimates[k,c('Recrudescence_mean_theta',
                                                       'ReInfection_mean_theta',
                                                       'Relapse_mean_theta')]
}
```

```{r}
# This takes a while to run....
# if(RUN_MODELS_CLUSTER){
#   tic()
#   Res = post_prob_CLI(MS_data = MS_pooled_pairs, Fs = Fs_Combined, p = P_matrix, cores = 42)
#   Res = do.call(rbind, Res)
#   save(Res, file = '../RData/GeneticModel/Pooled_Analysis_Inflation_Results.RData')
#   toc()
# } else {
#   load('../RData/GeneticModel/Pooled_Analysis_Inflation_Results.RData')
# }
```

Construct adjacency graphs and compute probabilities of relapse and reinfection.
```{r}
# if(CREATE_PLOTS){
#   MS_pooled$TotalEpisodes = MS_pooled$ClusterID = NA
#   
#   for(id in unique(MS_pooled$ID)){
#     MS_pooled$TotalEpisodes[MS_pooled$ID==id] = max(MS_pooled$Episode[MS_pooled$ID==id])
#   }
#   # Arrange by complexity
#   MS_pooled = arrange(MS_pooled, TotalEpisodes, ID)
#   # Get single rows per episode (throw away the extra MOI information)
#   Pooled_Data = MS_pooled[!duplicated(MS_pooled$Episode_Identifier),]
#   Pooled_Data$ID = as.factor(Pooled_Data$ID)
#   Pooled_Data$NumberClusters = NA
#   mycols = brewer.pal(3,'Set1')
#   
#   ## Threshold value
#   Epsilon = .5
#   ids = names(table(MS_pooled$ID[!duplicated(MS_pooled$Episode_Identifier)]))
#   ind = table(MS_pooled$ID[!duplicated(MS_pooled$Episode_Identifier)]) > 1
#   Multi_Eps_IDs = ids[ind]
#   
#   
#   Graphs=list()
#   
#   for(i in 1:length(Multi_Eps_IDs)){
#     id = Multi_Eps_IDs[i]
#     Neps = max(MS_pooled$Episode[MS_pooled$ID==id])
#     Adj_Matrix = array(0, dim = c(Neps,Neps))
#     diag(Adj_Matrix) = 1/2
#     colnames(Adj_Matrix) = 1:Neps
#     rownames(Adj_Matrix) = 1:Neps
#     # Going to sum the reLapse probability and the reCrudescence probability
#     Doubles_Thetas = filter(Res, ID_True==id)
#     Doubles_Thetas = Doubles_Thetas[duplicated(Doubles_Thetas$ID),]
#     Is = Doubles_Thetas$First_EpNumber
#     Js = Doubles_Thetas$Second_EpNumber
#     for(k in 1:nrow(Doubles_Thetas)){
#       Adj_Matrix[Is[k],Js[k]] = Doubles_Thetas$Thetas[k]
#     }
#     Adj_Matrix = Adj_Matrix + t(Adj_Matrix)
#     Adj_Matrix[ Adj_Matrix < Epsilon ] = 0
#     Adj_Matrix[ Adj_Matrix >= Epsilon ] = 1
#     Graphs[[i]] = graph_from_adjacency_matrix(Adj_Matrix, mode = "undirected",diag = F)
#     # Add the number of clusters
#     Pooled_Data$NumberClusters[Pooled_Data$ID==id] = components(Graphs[[i]])$no
#     # Add the membership of each cluster
#     Pooled_Data$ClusterID[Pooled_Data$ID==id] = components(Graphs[[i]])$membership
#   }
# }
```