---
title: "Pooled Analysis"
author: "Aimee Taylor and James Watson"
output:
  html_document:
    df_print: paged
    keep_md: TRUE
  pdf_document: default
  keep_md: TRUE
  html_notebook: default
---

# Preamble

Load R packages, functions and data.

```{r, echo=FALSE, include=FALSE}
#==========================================================================
# Set up
#==========================================================================
knitr::opts_chunk$set(cache = TRUE, cache.comments = FALSE, 
                      echo = FALSE, include = TRUE, 
                      fig.width = 7, fig.height = 7,
                      fig.pos = 'H', 
                      dev = 'png', dpi = 300)

require(plyr)
require(dplyr) # For filter
require(gtools) # For permutations
require(tictoc) # For bdiag()
require(doParallel) # For post_prob_R
require(Matrix)
require(matrixStats) # for logSumExp
library(igraph) # For igraph
require(RColorBrewer)
require(knitr) # for kable()
load('../RData/TimingModel/MOD3_theta_estimates.RData')
load('../RData/TimingModel/MOD3_Posterior_samples.RData')
load('../RData/TimingModel/Combined_Time_Event.RData')

source("../Genetic_Model/Data_functions.R")
source('../Genetic_Model/iGraph_functions.R')
source("../Genetic_Model/post_prob_CLI.R") 
source("../Genetic_Model/post_prob_CLI_sequential.R") 
source("../Genetic_Model/test_Rn_compatible.R") 
source("../Genetic_Model/Data_Inflation_Functions.R")
source('../Plotting_MS_Data/PlottingFunction.R')

# The pooled MS data from BPD and VHX
load('../RData/GeneticModel/MS_data_PooledAnalysis.RData')

# Booleans that describe generation of Markdown file. 
# The large jobs are done on the cluster
RUN_MODELS_SINGLE_SIMPLE = F
RUN_MODELS_FULL_POSTERIOR_SIMPLE = F
RUN_MODELS_FULL_POSTERIOR_INFLATED = F
RUN_MODELS_FALSE_POSITIVE = F
CREATE_PLOTS = T
```


Summary of the data and the whole of the VHX data versus the subset typed (in terms of number of episodes):

```{r, echo=FALSE}
writeLines(sprintf('Number of individuals with at least one episode typed: %s',
                   length(unique(MS_pooled$ID))))
writeLines(sprintf('Number of episodes typed: %s',
                   length(unique(MS_pooled$Episode_Identifier))))
writeLines(sprintf('Number of recurrences typed: %s',
                   length(unique(MS_pooled$Episode_Identifier[MS_pooled$Episode>1]))))

# We also remove MS data for which there are no recurrent data
N_episodes_typed = table(MS_pooled$ID[!duplicated(MS_pooled$Episode_Identifier)])
MS_pooled = filter(MS_pooled, ID %in% names(N_episodes_typed[N_episodes_typed>1]))

writeLines(sprintf('Number of individuals with at least two episodes typed: %s',
                   length(unique(MS_pooled$ID))))
writeLines(sprintf('Number of episodes individuals with at least two episodes typed: %s',
                   length(unique(MS_pooled$Episode_Identifier))))
writeLines(sprintf('Number of recurrences typed: %s',
                   length(unique(MS_pooled$Episode_Identifier[MS_pooled$Episode>1]))))
```


```{r}
# James, there are some odd bugs something to do with !duplicated() and the tibble...
# https://stackoverflow.com/questions/39041115/fixing-a-multiple-warning-unknown-column

# Were all episodes typed if person was selected for genotyping? 
MS_pooled_summary = MS_pooled[!duplicated(MS_pooled$Episode_Identifier),] # Collapse rows due to COI > 2
All_VHX_epi_count = table(Combined_Time_Data$patientid[grep('VHX',Combined_Time_Data$patientid)])
All_BPD_epi_count = table(Combined_Time_Data$patientid[grep('BPD',Combined_Time_Data$patientid)])
Typ_VHX_epi_count =  table(MS_pooled_summary$ID[grep('VHX',MS_pooled_summary$Episode_Identifier)]) # Typed_VHX_epi_count
Typ_BPD_epi_count =  table(MS_pooled_summary$ID[grepl('BPD_',MS_pooled_summary$Episode_Identifier)]) # Typed_BPD_epi_count

# VHX data set
no_person_typed = All_VHX_epi_count[names(All_VHX_epi_count) %in% names(Typ_VHX_epi_count)][names(Typ_VHX_epi_count)]
no_typed_person_typed = Typ_VHX_epi_count 
X0 = sum(no_person_typed == no_typed_person_typed) # 90% completely typed
X1 = length(no_typed_person_typed)
X2 = range((no_person_typed - no_typed_person_typed)[no_person_typed != no_typed_person_typed]) 
writeLines(sprintf('Of %s of %s VHX individual/s selected for genotyping, %s to %s of their episodes were not typed',
                   X0,X1,X2[1],X2[2]))

# BPD data set
no_person_typed = All_BPD_epi_count[names(All_BPD_epi_count) %in% names(Typ_BPD_epi_count)][names(Typ_BPD_epi_count)]
no_typed_of_typed = Typ_BPD_epi_count
X0 = sum(no_person_typed == no_typed_of_typed)
X1 = length(no_typed_of_typed)
X2 = range((no_person_typed - no_typed_of_typed)[no_person_typed != no_typed_of_typed]) # missing 1 if missing
writeLines(sprintf('Of %s of %s BPD individual/s selected for genotyping, %s to %s of their episodes were not typed',
                   X0,X1,X2[1],X2[2]))
```

```{r}
# Is there a significant difference between VHX that where genetically typed and not? 
All_VHX_rec_count = All_VHX_epi_count[All_VHX_epi_count > 1] # Condition on those that have one or more recurrence 
x1 = Typ_VHX_epi_count 
x2 = All_VHX_rec_count[!names(All_VHX_rec_count) %in% names(x1)] # Untyped_VHX_epi_count
max_rec = max(All_VHX_rec_count)

plot_store = array(dim = c(2, max_rec-1), dimnames = list(c('Untyped','Typed'), 2:max_rec))
plot_store['Untyped', names(table(x2))] = table(x2)
plot_store['Typed', names(table(x1))] = table(x1)

barplot(plot_store, col = c('lightgray','red'), beside = T, density = c(100,25), 
     main='VHX subset', xlab = 'Number of episodes')
legend('topright', legend = c('Untyped', 'Typed'), fill =c('lightgray', 'red'), 
       density = c(100,25), bty = 'n')

# Bootstap test of difference in median
theta_hat = median(x1) - median(x2) # Median diff 2
theta_hat_boot = sapply(1:5000, function(x){
  x1boot = sample(x1, size = length(x1), replace = T)
  x2boot = sample(x2, size = length(x2), replace = T)
  median(x1boot) - median(x2boot)})
se = sd(theta_hat_boot) 
Normal_95CI = c(theta_hat - 1.96*se, theta_hat + 1.96*se)  # Significant
percentile_95CI = quantile(theta_hat_boot, probs = c(0.025, 0.975)) # Not significant
pivotal_95CI = 2*theta_hat - rev(percentile_95CI) # Significant
```

Summary of complexity of infection based on numbers of alleles observed 
(could later compare between relapse / reinfection)

```{r}
COIs = sapply(unique(MS_pooled$Episode_Identifier), function(x){
 ind = MS_pooled$Episode_Identifier == x
 max(MS_pooled$MOI_id[ind])
})
x1 = COIs[grepl('VHX', names(COIs))]
x2 = COIs[grepl('BPD', names(COIs))]
theta_hat = median(x1) - median(x2) # Median diff 0

COIs_store = array(0, dim = c(2, max(COIs)), dimnames = list(c('VHX','BPD'), 1:max(COIs)))
COIs_store['VHX', names(table(x1))] = table(x1)
COIs_store['BPD', names(table(x2))] = table(x2)
barplot(COIs_store, col = c('lightgray','red'), beside = T, density = c(100,25), 
     main='COIs', xlab = 'COIs')
legend('topright', legend = c('VHX', 'BPD'), fill =c('lightgray', 'red'), 
       density = c(100,25), bty = 'n')

# How many could have have sibs? 
X0 = sum(COIs >= 3)
X1 = round(sum(COIs >= 3)/length(COIs)*100, 2)

writeLines(sprintf('Median COI in VHX and BPD: %s and %s, respectively', median(x1), median(x2)))
writeLines(sprintf('Number of episodes with COI >= 3: %s of %s (%s percent)', X0, length(COIs), X1))
```

Define the sets of microsatellite markers for the various datasets.

```{r}
MSs_VHX = c("PV.3.502","PV.3.27","PV.ms8","PV.1.501","PV.ms1","PV.ms5","PV.ms6")
MSs_all = c("PV.3.502","PV.3.27","PV.ms8","PV.1.501","PV.ms1","PV.ms5","PV.ms6",
            "PV.ms7","PV.ms16")
MSs_BPD = MSs_all
MSs_Main = c('PV.3.27', 'PV.3.502', 'PV.ms8') # These are typed for all episodes (the core group)
```


The approach is fully Bayesian and consists of the following:

* A prior probability vector for the recurrence state
* A likelihood based on the genetic data of being a *relapse*, a *recrudescence*, or a *reinfection* given the observed microsatellite data.

# Allele frequencies

We use a multinomial-dirichlet model with subjective weight $\omega$. $\omega = 0$ recovers unweighted empirical allele frequencies. 

```{r, echo=F}
# Prior weight for the Dirichlet (setting weight to 0 recovers empirical freq):
D_weight_Prior = 1

MSs_all = c("PV.3.502","PV.3.27","PV.ms8",
            "PV.1.501","PV.ms1","PV.ms5",
            "PV.ms6", "PV.ms7","PV.ms16")

# These are motif lengths: for the plotting
MSs_Motifs = list("PV.3.502"=8,'PV.3.27' = 4, 
                  "PV.ms8" = 3, "PV.1.501"= 7, 
                  "PV.ms1" = 3, "PV.ms5" = 3,
                  "PV.ms6" = 3, "PV.ms16" =3,
                  "PV.ms7" = 3)

writeLines(paste('Number of episodes used to compute frequencies:',
                 sum(MS_pooled$Episode==1 & MS_pooled$MOI_id==1)))
Ind_Primary = which(MS_pooled$Episode==1)

# Posterior Dirichlet parameter vector
Alpha_Posteriors = apply(MS_pooled[,MSs_all], 2, function(x, Ind_Primary){
  # Extract xmax 
  xmax = max(x,na.rm=T)
  # prior parameter vector (iterpolates unobserved repeat lengths < xmax)
  param_vector = array(D_weight_Prior, dim = xmax, dimnames = list(1:xmax)) 
  # observed data summarised as counts
  obs_counts = table(x[Ind_Primary]) 
  # posterior parameter vector
  param_vector[names(obs_counts)] = param_vector[names(obs_counts)] + obs_counts
  return(param_vector)
})

# Calculate posterior mean 
Fs_Combined = sapply(Alpha_Posteriors, function(x){x/sum(x)})
```


## Plotting allele frequencies

These are the observed allele frequencies in the pooled data. We show 80% credible intervals (lo) (Aimee: seems to be 95%)

```{r AlleleFrequencies, echo=F}
if(CREATE_PLOTS){
  par(mfrow=c(3,3), las=1, bty='n', cex.axis=1.2)
  
  for(ms in MSs_all){ # As bars
    K = length(Fs_Combined[[ms]]) # Cardinality of ms 
    xs = rdirichlet(n = 1000, alpha = Alpha_Posteriors[[ms]]) # Sample from posterior
    # MC approximation of 0.9 percentile expressed as percentage
    YMAX = max(apply(100*xs, 2, quantile, probs = .9)) 
    # Number of observations
    N_MS = length(unique(MS_pooled$ID[MS_pooled$Episode==1 & !is.na(MS_pooled[,ms])]))
    plot(1:ncol(xs), rep(NA,K), 
         main = sprintf('%s (n = %s)', ms, N_MS),
         pch = 18, ylim=c(0,YMAX),col='red',
         ylab='%', xlab='', yaxt='n')
    abline(h=100/K)
    mtext(text = paste('Motif length:',MSs_Motifs[[ms]]),side = 1,line=3)
    for(k in 1:ncol(xs)){
      lines(rep(k,2), 100*quantile(xs[,k],probs = c(0.025,0.975)), col='blue')
    }
    points(1:length(Fs_Combined[[ms]]),
           100*Fs_Combined[[ms]],col='red',pch=18)
    
    axis(2, seq(0, round(YMAX), length.out = 3))
  }
}
```


# Computing the probability of relatedness across infections

The following iterates through each individual and computes the probability of relatedness states.

## Load the time-to-event priors

```{r}
inds = grepl('mean_theta', colnames(Mod3_ThetaEstimates)) # Extract mean
p = data.frame(Episode_Identifier = Mod3_ThetaEstimates$Episode_Identifier, 
               Mod3_ThetaEstimates[,inds],
               stringsAsFactors = F) # Reformat
colnames(p) = gsub(pattern = 'Recrudescence_mean_theta',replacement = 'C',x = colnames(p))
colnames(p) = gsub(pattern = 'Relapse_mean_theta',replacement = 'L',x = colnames(p))
colnames(p) = gsub(pattern = 'ReInfection_mean_theta',replacement = 'I',x = colnames(p))

genetic_AND_time_data_eps = intersect(p$Episode_Identifier, MS_pooled$Episode_Identifier)
p = p[p$Episode_Identifier %in% genetic_AND_time_data_eps,]
Post_samples_matrix = Post_samples_matrix[Post_samples_matrix$Episode_Identifier %in% genetic_AND_time_data_eps,]
```


## Computation using full dataset 

We use all 9MS markers (when available).
```{r, include=FALSE}
if(RUN_MODELS_SINGLE_SIMPLE){
  #===============================================
  # Run new version (with time-to-event)
  #===============================================
  tic()
  thetas_9MS = post_prob_CLI(MS_data = MS_pooled, Fs = Fs_Combined, 
                             p = p, cores = 6, verbose = F) 
  thetas_9MS$Episode_Identifier = rownames(thetas_9MS)
  save(thetas_9MS, file = '../RData/GeneticModel/thetas_9MS.RData')
  toc()
  
  #===============================================
  # Run new version (without time-to-event)
  #===============================================
  tic()
  thetas_9MS_Tagnostic = post_prob_CLI(MS_data = MS_pooled, Fs = Fs_Combined, 
                                       cores = 6, verbose = F)
  thetas_9MS_Tagnostic$Episode_Identifier = rownames(thetas_9MS_Tagnostic)
  save(thetas_9MS_Tagnostic, file = '../RData/GeneticModel/thetas_9MS_Tagnostic.RData')
  toc()
} else {
  load('../RData/GeneticModel/thetas_9MS.RData')
  load('../RData/GeneticModel/thetas_9MS_Tagnostic.RData')
}
```

### Full posterior computation

```{r, include=FALSE}
if(RUN_MODELS_FULL_POSTERIOR_SIMPLE){
  #===============================================
  # Run full Bayesian with sampling at random from time prior
  # takes about 15-20 minutes on 6 cores
  # The outer loop is not parallelised - not optimal coding
  #===============================================
  
  Ksamples = length(grep('C',colnames(Post_samples_matrix)))
  tic()
  Thetas_full_post = foreach(ss = 1:Ksamples, .combine = cbind) %do% {
    # draw a random distribution over the allele frequencies from posterior
    Fs_random = lapply(Alpha_Posteriors, rdirichlet, n=1)
    # I'm not sure if this is needed - how are these called deep inside?
    for(i in 1:length(Fs_random)){
      names(Fs_random[[i]]) = 1:length(Fs_random[[i]])
    }
    # take the ss sample from the time prior
    indices = c(grep('C',colnames(Post_samples_matrix))[ss],
                grep('L',colnames(Post_samples_matrix))[ss],
                grep('I',colnames(Post_samples_matrix))[ss],
                grep('Episode_Identifier',colnames(Post_samples_matrix)))
    p = Post_samples_matrix[,indices]
    thetas_9MS = post_prob_CLI(MS_data = MS_pooled, Fs = Fs_random, 
                               p = p, cores = 6, verbose = F) 
    thetas_9MS$Episode_Identifier = rownames(thetas_9MS)
    thetas_9MS
  }
  save(Thetas_full_post, file = '../RData/GeneticModel/Full_Posterior_Model_samples.RData')
  toc()
} else {
  load(file = '../RData/GeneticModel/Full_Posterior_Model_samples.RData')
}
```


# Plot results

These dataframes are sorted by episode number so the columns correspond between them. We make some data.frames that store the results for ease of plotting.

```{r}
mycols = brewer.pal(n=3, name = 'Set1')
thetas_9MS = arrange(thetas_9MS, Episode_Identifier)
thetas_9MS_Tagnostic = arrange(thetas_9MS_Tagnostic, Episode_Identifier)

Time_Estimates_1 = filter(Mod3_ThetaEstimates, 
                          Episode_Identifier %in% thetas_9MS$Episode_Identifier)
Time_Estimates_1 = arrange(Time_Estimates_1, Episode_Identifier)

thetas_9MS$drug = Time_Estimates_1$arm_num
thetas_9MS_Tagnostic$drug = Time_Estimates_1$arm_num

# for plotting
thetas_9MS$drug_col = mapvalues(x = thetas_9MS$drug, 
                                c('AS','CHQ','CHQ/PMQ'), mycols)
thetas_9MS_Tagnostic$drug_col = mapvalues(x = thetas_9MS_Tagnostic$drug, 
                                          c('AS','CHQ','CHQ/PMQ'), mycols)

```

```{r}
BPD_data = Thetas_full_post[grep('BPD',rownames(Thetas_full_post)),]
Thetas_BPD = thetas_9MS[grep('BPD', thetas_9MS$Episode_Identifier),]


# Added by Aimee: some examples
# Colour some specific examples 
example_inds = grepl('_644_', Thetas_BPD$Episode_Identifier) | 
  grepl('BPD_598_', Thetas_BPD$Episode_Identifier) | 
  grepl('BPD_562_', Thetas_BPD$Episode_Identifier) |
  grepl('BPD_53_', Thetas_BPD$Episode_Identifier) 
example_ids = Thetas_BPD$Episode_Identifier[example_inds]
example_inds_times = MS_pooled$timeSinceLastEpisode[MS_pooled$Episode_Identifier %in% example_ids]
Tagnostic_example_inds = thetas_9MS_Tagnostic$Episode_Identifier %in% example_ids
thetas9MS_example_inds = thetas_9MS$Episode_Identifier %in% example_ids
Time1_example_inds = Time_Estimates_1$Episode_Identifier %in% example_ids

```

## Going from time-to-event prior to posterior

Have broken it down by radical cure and no radical cure, as that is the most informative distinction here.

```{r}
if(CREATE_PLOTS){
  par(mfrow=c(2,2),las=1, bty='n')
  # Time agnostic versus full posterior 
  plot(log10(thetas_9MS_Tagnostic$L), log10(thetas_9MS$L), 
       col = thetas_9MS$drug_col, main = 'Relapse',pch=20,
       xlab = 'Time agnostic', ylab = 'Time included')
  lines(-10:0,-10:0)
  
  # Annotate by examples
  points(x = log10(thetas_9MS_Tagnostic$L[Tagnostic_example_inds]), 
         y = log10(thetas_9MS$L[thetas9MS_example_inds]), 
         pch=1, cex = 1.5, col='black')
  text(x = log10(thetas_9MS_Tagnostic$L[Tagnostic_example_inds]), 
       y = log10(thetas_9MS$L[thetas9MS_example_inds]), 
       labels = example_ids, pos = 2, cex = 0.7)
  
  plot(log10(thetas_9MS_Tagnostic$I), log10(thetas_9MS$I), 
       col=thetas_9MS$drug_col, main = 'Reinfection',pch=20,
       xlab = 'Time agnostic', ylab = 'Time included')
  lines(-20:0,-20:0)
  
  
  ##### Prior versus full posterior
  plot(log10(Time_Estimates_1$Relapse_mean_theta),
       log10(thetas_9MS$L),main = 'Relapse',
       col=thetas_9MS$drug_col,pch=20,
       xlab = 'Time based prior', ylab = 'Full posterior')
  lines(-10:10,-10:10)
  
  # Annotate by examples
  points(x = log10(Time_Estimates_1$Relapse_mean_theta[Time1_example_inds]), 
         y = log10(thetas_9MS$L[thetas9MS_example_inds]), 
         pch=1, cex = 1.5, col='black')
  text(x = log10(Time_Estimates_1$Relapse_mean_theta[Time1_example_inds]), 
       y = log10(thetas_9MS$L[thetas9MS_example_inds]), 
       labels = example_ids, pos = 2, cex = 0.7)
  
  plot(log10(Time_Estimates_1$ReInfection_mean_theta),
       log10(thetas_9MS$I),main = 'Reinfection',
       col=thetas_9MS$drug_col,pch=20,
       xlab = 'Time based prior', ylab = 'Full posterior')
  lines(-10:10,-10:10)
  
}
```

Probability of relapse, ordered from most to least likely:
```{r, fig.width=10}
if(CREATE_PLOTS){
  
  par(mfrow=c(1,2),las=1, bty='n')
  
  reLapse_ordered = sort.int(thetas_9MS$L, decreasing = TRUE, index.return = TRUE)
  plot(reLapse_ordered$x, pch=20, col = thetas_9MS$drug_col[reLapse_ordered$ix],
       xlab = 'Recurrence index', ylab = 'Probability of relapse state',
       main = 'Full posterior: reLapse')
  CI = cbind(apply(
    Thetas_full_post[reLapse_ordered$i,grep('L',colnames(Thetas_full_post)),],
    1, quantile, probs = 0.025), 
    apply(Thetas_full_post[reLapse_ordered$i,grep('L',colnames(Thetas_full_post)),],
          1, quantile, probs = 0.975))
  for(i in 1:length(reLapse_ordered$x)){
    if(diff(CI[i,]) > 0.005) arrows(i,CI[i,1],i,CI[i,2], 
                                    length = 0.02,angle = 90, 
                                    code = 3,
                                    col=thetas_9MS$drug_col[reLapse_ordered$ix[i]])
  }
  
  legend('topright',col = mycols[2:3], bty = 'n', 
         legend = c('No radical cure','Radical cure'),pch=20)
  
  reLapse_ordered_Tagn = sort.int(thetas_9MS_Tagnostic$L, 
                                  decreasing = TRUE, index.return = TRUE)
  plot(reLapse_ordered_Tagn$x, pch=20, cex=.8,
       col = thetas_9MS_Tagnostic$drug_col[reLapse_ordered_Tagn$ix],
       xlab = 'Recurrence index', ylab = 'Probability of relapse state',
       main = 'Time agnostic posterior: reLapse')
  legend('topright',col = mycols[2:3], bty = 'n', 
         legend = c('No radical cure','Radical cure'),pch=20)
}
```

Probability of reinfection, ordered from most to least likely:
```{r, fig.width=10}
if(CREATE_PLOTS){
  
  par(mfrow=c(1,2),las=1, bty='n')
  reinfection_ordered = sort.int(thetas_9MS$I, decreasing = TRUE, index.return = TRUE)
  plot(reinfection_ordered$x, pch=20, col = thetas_9MS$drug_col[reinfection_ordered$ix],
       xlab = 'Recurrence index', ylab = 'Probability of reinfection state',
       main = 'Full posterior: reInfection')
  legend('topright',col = mycols[2:3],bty = 'n',  
         legend = c('No radical cure','Radical cure'),pch=20)
  
  reinfection_ordered_Tagn = sort.int(thetas_9MS_Tagnostic$I, decreasing = TRUE, index.return = TRUE)
  plot(reinfection_ordered_Tagn$x, pch=20, cex=.8,
       col = thetas_9MS_Tagnostic$drug_col[reinfection_ordered_Tagn$ix],
       xlab = 'Recurrence index', ylab = 'Probability of reinfection state',
       main = 'Time agnostic posterior: reInfection')
  legend('topright',col = mycols[2:3],bty = 'n',  
         legend = c('No radical cure','Radical cure'),pch=20)
}
```

Probability of recrudescence, ordered from most to least likely:
```{r, fig.width=10}
if(CREATE_PLOTS){
  par(mfrow=c(1,2),las=1, bty='n')
  recrud_ordered = sort.int(thetas_9MS$C, decreasing = TRUE, index.return = TRUE)
  plot(recrud_ordered$x, pch=20, col = thetas_9MS$drug_col[recrud_ordered$ix],
       xlab = 'Recurrence index', ylab = 'Probability of recrudescence state',
       main = 'Full posterior: reCrudescence')
  legend('topright',col = mycols[2:3],bty = 'n',  
         legend = c('No radical cure','Radical cure'),pch=20)
  
  recrud_ordered_Tagn = sort.int(thetas_9MS_Tagnostic$C, decreasing = TRUE, index.return = TRUE)
  plot(recrud_ordered_Tagn$x, pch=20, cex=.8,
       col = thetas_9MS_Tagnostic$drug_col[recrud_ordered_Tagn$ix],
       xlab = 'Recurrence index', ylab = 'Probability of recrudescence state',
       main = 'Time agnostic posterior: reCrudescence')
  legend('topright',col = mycols[2:3],bty = 'n',  
         legend = c('No radical cure','Radical cure'),pch=20)
}
```

# BPD Final Plot

```{r BPD_efficacy, fig.width=10}
# Get rid of duplicated episode IDs (MOI > 1)
MS_pooled_summary = MS_pooled[!duplicated(MS_pooled$Episode_Identifier),]

if(CREATE_PLOTS){
  par(mfrow=c(1,2),las=1, bty='n')
  reLapse_ordered = sort.int(Thetas_BPD$L, decreasing = TRUE, index.return = TRUE)
  plot(reLapse_ordered$x, pch=20, col = Thetas_BPD$drug_col[reLapse_ordered$ix],
       xlab = 'Recurrence index', ylab = 'Probability of relapse',
       main = '')
  CI = cbind(apply(
    BPD_data[reLapse_ordered$ix,grep('L',colnames(BPD_data)),],
    1, quantile, probs = 0.025), 
    apply(BPD_data[reLapse_ordered$ix,grep('L',colnames(BPD_data)),],
          1, quantile, probs = 0.975))
  for(i in 1:length(reLapse_ordered$x)){
    if(diff(CI[i,]) > 0.005) arrows(i,CI[i,1],i,CI[i,2], 
                                    length = 0.02,angle = 90, 
                                    code = 3,
                                    col=Thetas_BPD$drug_col[reLapse_ordered$ix[i]])
  }
  
  writeLines(sprintf('The mean percentage of recurrences which are estimated to be relapses is %s%%',
                     round(100*sum(Thetas_BPD$L + Thetas_BPD$C)/nrow(Thetas_BPD))))
  
  
  plot(NA,NA,xlim=c(0,max(MS_pooled_summary$timeSinceLastEpisode,na.rm=T)), ylim=c(0,1),
       ylab = 'Probability of relapse', xlab = 'Time since last episode')
  for(i in 1:length(reLapse_ordered$x)){
    kk = reLapse_ordered$ix[i]
    x_time = MS_pooled_summary$timeSinceLastEpisode[Thetas_BPD$Episode_Identifier[kk]==
                                                      MS_pooled_summary$Episode_Identifier]
    points(x_time,
           Thetas_BPD$L[kk], pch=20, col=mycols[3])
    if(diff(CI[i,]) > 0.005) arrows(x_time,CI[i,1],x_time,CI[i,2], 
                                    length = 0.02,angle = 90, 
                                    code = 3,
                                    col=Thetas_BPD$drug_col[reLapse_ordered$ix[i]])
  }
  
  # Annotate by examples
  # points(example_inds_times,Thetas_BPD$L[example_inds], pch=1, cex = 1.5, col='black')
  # text(x = example_inds_times, y = Thetas_BPD$L[example_inds], 
  #      labels = example_ids, pos =3)
}
```


# Extra computations for VHX: too complex episodes


We remove the IDs that can be straightforwardly calculated:
```{r}
ind_calculated = which(MS_pooled_summary$Episode_Identifier %in% thetas_9MS$Episode_Identifier)
IDs_calculated = unique(MS_pooled_summary$ID[ind_calculated])
IDs_remaining = unique(MS_pooled_summary$ID[! MS_pooled_summary$ID %in% IDs_calculated])
```

We blow up the pooled analysis into all pairs within individuals:
```{r, include=FALSE}
MS_inflate = filter(MS_pooled_summary, MS_pooled_summary$ID %in% IDs_remaining)
MS_inflated = Inflate_into_pairs(MS_data = MS_inflate)

if(RUN_MODELS_FULL_POSTERIOR_INFLATED){  
  
  all_rec_eps = unique(MS_inflated$Episode_Identifier[MS_inflated$Episode==2])
  P_matrix = data.frame(array(dim = c(length(all_rec_eps),4)))
  colnames(P_matrix) = c('Episode_Identifier','C','I','L')
  P_matrix$Episode_Identifier = all_rec_eps
  Ksamples = length(grep('C',colnames(Post_samples_matrix)))
  
  K_results = sum(!duplicated(MS_inflated$Episode_Identifier[MS_inflated$Episode>1]))
  Res_total = array(NA, dim = c(K_results, 3*Ksamples))
  
  tic()
  Res_total=foreach(ss = 1:Ksamples, .combine = cbind) %do% {
    
    # draw a random distribution over the allele frequencies from posterior
    Fs_random = lapply(Alpha_Posteriors, rdirichlet, n=1)
    # I'm not sure if this is needed - how are these called deep inside?
    for(i in 1:length(Fs_random)){
      names(Fs_random[[i]]) = 1:length(Fs_random[[i]])
    }
    # take the ss sample from the time prior
    rec_states = c('C','L','I')
    indices = c(grep(rec_states[1],colnames(Post_samples_matrix))[ss],
                grep(rec_states[2],colnames(Post_samples_matrix))[ss],
                grep(rec_states[3],colnames(Post_samples_matrix))[ss])
    for(ep in all_rec_eps){
      i = which(P_matrix$Episode_Identifier==ep)
      j = which(MS_inflated$Episode_Identifier==ep)[1]
      k = which(Post_samples_matrix$Episode_Identifier == paste(MS_inflated$ID_True[j],
                                                                MS_inflated$Second_EpNumber[j],
                                                                sep='_'))
      P_matrix[i,rec_states] = Post_samples_matrix[k,indices]
    }
    
    Res = post_prob_CLI(MS_data = MS_inflated, 
                        Fs = Fs_random, 
                        p = P_matrix,
                        UpperComplexity = 10^8, 
                        verbose = F,
                        cores = 42)
    Res
  }
  rownames(Res_total) = rownames(Res)
  save(Res_total, file = 'FullPosterior_INF.bigRData')
  toc()
} else {
  load('FullPosterior_INF.bigRData')
}

# Summarise the results
Res = data.frame(Episode_Identifier = rownames(Res_total),
                 C_mean = apply(Res_total[,grep('C',colnames(Res_total))],1,
                                quantile,probs = 0.5,na.rm=T),
                 C_min = apply(Res_total[,grep('C',colnames(Res_total))],1,
                               quantile,probs = 0.1,na.rm=T),
                 C_max = apply(Res_total[,grep('C',colnames(Res_total))],1,
                               quantile,probs = 0.9,na.rm=T),
                 L_min = apply(Res_total[,grep('L',colnames(Res_total))],1,
                               quantile,probs = 0.1,na.rm=T),
                 L_max = apply(Res_total[,grep('L',colnames(Res_total))],1,
                               quantile,probs = 0.9,na.rm=T),
                 L_mean = apply(Res_total[,grep('L',colnames(Res_total))],1,
                                quantile,probs = 0.5,na.rm=T),
                 I_mean = apply(Res_total[,grep('I',colnames(Res_total))],1,
                                quantile,probs = 0.5,na.rm=T),
                 I_min = apply(Res_total[,grep('I',colnames(Res_total))],1,
                               quantile,probs = 0.1,na.rm=T),
                 I_max = apply(Res_total[,grep('I',colnames(Res_total))],1,
                               quantile,probs = 0.9,na.rm=T))
```


Construct adjacency graphs and compute probabilities of relapse and reinfection.
```{r}
MS_pooled_summary$L_or_C_state = MS_pooled_summary$TotalEpisodes = NA
MS_pooled_summary$L_lower = MS_pooled_summary$L_upper = MS_pooled_summary$L_mean = NA
MS_pooled_summary$C_lower = MS_pooled_summary$C_upper = MS_pooled_summary$C_mean = NA
MS_pooled_summary$I_lower = MS_pooled_summary$I_upper = MS_pooled_summary$I_mean = NA
# Arrange by complexity
# Get single rows per episode (throw away the extra MOI information)
MS_inflated = MS_inflated[!duplicated(MS_inflated$Episode_Identifier) & MS_inflated$Episode>1,]
Res$ID_True = MS_inflated$ID_True
Res$First_EpNumber = MS_inflated$First_EpNumber
Res$Second_EpNumber = MS_inflated$Second_EpNumber


## Threshold value for classification
Epsilon = 0.5

# Iterate through the ones we can calculate in one go
episodes_full_model = unique(Thetas_full_post$Episode_Identifier)
cols_remove = grep('Episode_Identifier', colnames(Thetas_full_post))
Thetas_full_post = Thetas_full_post[, -cols_remove]
for(ep in episodes_full_model){
  ind1 = (MS_pooled_summary$Episode_Identifier==ep)
  ind2 = rownames(Thetas_full_post)==ep
  
  ## Summaries for relapse
  MS_pooled_summary$L_upper[ind1] = quantile(unlist(Thetas_full_post[ind2, grep('L',colnames(Thetas_full_post))]),
                                             probs=0.9)
  MS_pooled_summary$L_lower[ind1] = quantile(unlist(Thetas_full_post[ind2, grep('L',colnames(Thetas_full_post))]),
                                             probs=0.1)
  MS_pooled_summary$L_mean[ind1] = quantile(unlist(Thetas_full_post[ind2, grep('L',colnames(Thetas_full_post))]),
                                            probs=0.5)
  
  ## Summaries for recrudescence
  MS_pooled_summary$C_upper[ind1] = quantile(unlist(Thetas_full_post[ind2, grep('C',colnames(Thetas_full_post))]),
                                             probs=0.9)
  MS_pooled_summary$C_lower[ind1] = quantile(unlist(Thetas_full_post[ind2, grep('C',colnames(Thetas_full_post))]),
                                             probs=0.1)
  MS_pooled_summary$C_mean[ind1] = quantile(unlist(Thetas_full_post[ind2, grep('C',colnames(Thetas_full_post))]),
                                            probs=0.5)
  
  ## Summaries for reinfection
  MS_pooled_summary$I_upper[ind1] = quantile(unlist(Thetas_full_post[ind2, grep('I',colnames(Thetas_full_post))]),
                                             probs=0.9)
  MS_pooled_summary$I_lower[ind1] = quantile(unlist(Thetas_full_post[ind2, grep('I',colnames(Thetas_full_post))]),
                                             probs=0.1)
  MS_pooled_summary$I_mean[ind1] = quantile(unlist(Thetas_full_post[ind2, grep('I',colnames(Thetas_full_post))]),
                                            probs=0.5)
  
  # Just going to classify on relapse versus reinfection
  if(MS_pooled_summary$L_upper[ind1] < Epsilon){
    MS_pooled_summary$L_or_C_state[ind1] = 'I'
  } else if(MS_pooled_summary$L_lower[ind1] > Epsilon){
    MS_pooled_summary$L_or_C_state[ind1] = 'L'
  } else if(MS_pooled_summary$L_upper[ind1] > Epsilon & MS_pooled_summary$L_lower[ind1] < Epsilon){
    MS_pooled_summary$L_or_C_state[ind1] = 'Uncertain'
  }
}
for(i in 1:length(IDs_remaining)){
  id = IDs_remaining[i]
  Doubles_Thetas = filter(Res, ID_True==id)
  
  for(ep in unique(Doubles_Thetas$Second_EpNumber)){
    ind1 = which(MS_pooled_summary$ID==id & MS_pooled_summary$Episode==ep)
    ind2 = which(Doubles_Thetas$Second_EpNumber == ep)
    
    MS_pooled_summary$L_lower[ind1] = mean(Doubles_Thetas$L_min[ind2])
    MS_pooled_summary$L_upper[ind1] = mean(Doubles_Thetas$L_max[ind2])
    MS_pooled_summary$L_mean[ind1] = mean(Doubles_Thetas$L_mean[ind2])
    
    MS_pooled_summary$C_lower[ind1] = mean(Doubles_Thetas$C_min[ind2])
    MS_pooled_summary$C_upper[ind1] = mean(Doubles_Thetas$C_max[ind2])
    MS_pooled_summary$C_mean[ind1] = mean(Doubles_Thetas$C_mean[ind2])
    
    MS_pooled_summary$I_lower[ind1] = mean(Doubles_Thetas$I_min[ind2])
    MS_pooled_summary$I_upper[ind1] = mean(Doubles_Thetas$I_max[ind2])
    MS_pooled_summary$I_mean[ind1] = mean(Doubles_Thetas$I_mean[ind2])
    
    if(!is.na(MS_pooled_summary$L_upper[ind1])){
      if(MS_pooled_summary$L_upper[ind1] < MS_pooled_summary$L_lower[ind1]){
        print(id)
      }
      if(MS_pooled_summary$L_upper[ind1] < Epsilon){
        MS_pooled_summary$L_or_C_state[ind1] = 'I'
      }
      if(MS_pooled_summary$L_lower[ind1] > Epsilon){
        MS_pooled_summary$L_or_C_state[ind1] = 'L'
      }
      if(MS_pooled_summary$L_upper[ind1] > Epsilon & 
         MS_pooled_summary$L_lower[ind1] < Epsilon){
        MS_pooled_summary$L_or_C_state[ind1] = 'Uncertain'
      }
    }
  }
}

MS_pooled_summary$Drug = MS_pooled_summary$FU = NA
for(id in MS_pooled_summary$ID){
  ind = MS_pooled_summary$ID==id
  MS_pooled_summary$TotalEpisodes[ind] = max(MS_pooled_summary$Episode[ind])
  MS_pooled_summary$Drug[ind] = as.numeric(
    Combined_Time_Data$arm_num[Combined_Time_Data$patientid==id][1] == 'CHQ/PMQ') + 2
  MS_pooled_summary$FU[ind] = Combined_Time_Data$FU_time[Combined_Time_Data$patientid==id][1]
}

MS_pooled_summary$Plotting_pch_Values = 
  as.numeric(mapvalues(MS_pooled_summary$L_or_C_state, 
                       from = c('L','Uncertain','I'), to = 15:17))
MS_pooled_summary$Plotting_col_Values = 
  as.numeric(mapvalues(MS_pooled_summary$L_or_C_state, 
                       from = c('L','Uncertain','I'), to = 1:3))
```

```{r CoatneyStylePLot, fig.heigh=10}
# Only the recurrences for which we can compute estimates of recurrence state
MS_final = filter(MS_pooled_summary, !is.na(L_mean))
MS_final = arrange(MS_final, desc(Drug), desc(FU), desc(TotalEpisodes))
ids = unique(MS_final$ID)

if(CREATE_PLOTS){
  ## Time series data colored by genetic STATE: classification
  mycols_states = c('red','yellow','black') # colors for states - need uncertain ones as well
  mycols_drugs = brewer.pal(n=3, name = 'Set1')
  par(las=1, bty='n', cex.axis=.3, mar=c(3,0,1,1))
  plot(NA, NA, xlim = c(0,370), ylim = c(1,length(ids)),
       xaxt='n', yaxt='n')
  mtext(text = 'Days from start of study', side = 1, line=2, cex=1.3)
  axis(1, at = seq(0,370, by=60), cex.axis=1.5)
  
  for(i in 1:length(ids)){
    
    id = ids[i]
    ind = which(MS_final$ID==id)
    
    # Add the follow up time line
    lines(c(0,MS_final$FU[ind[1]]), 
          c(i,i), lty=1, 
          lwd=.5, col= mycols_drugs[MS_final$Drug[ind[1]]])
    
    cols = mycols_states[MS_final$Plotting_col_Values[ind]]
    points(MS_final$timeSinceEnrolment[ind], rep(i,length(ind)), 
           pch=MS_final$Plotting_pch_Values[ind], 
           col=cols,cex=.6)
    
    # For highlighting long-latency
    # Add the follow up time line
    if(id == 'VHX_235' | id == 'BPD_27'){
      lines(c(0,MS_final$FU[ind[1]]), 
            c(i,i), lty = 'dashed', 
            lwd=.5, col= 'black')
      
      cols = mycols_states[MS_final$Plotting_col_Values[ind]]
      points(MS_final$timeSinceEnrolment[ind], rep(i,length(ind)), 
             pch=1, 
             col='black',cex=1)}
    
  }
  lines(x = c(0,0), y = c(0,length(ids)),lwd=3)
  # Hacky colour legend
  legend('topright', col = c('red', 'black', 'yellow',mycols_drugs[2:3]), 
         pch = c(15,17,16, NA,NA), cex = 0.7, bty = 'n', 
         lty = c(NA,NA,NA,1,1), lwd = c(NA,NA,NA,2,2),
         legend = c('Classified relapse', 'Classified reinfection', 'Uncertain',
                    'No radical cure', 'Radical cure'))
}
```

```{r CompleteDataPlot, fig.heigh=10}
if(CREATE_PLOTS){
  par(las=1, mfcol = c(2,1), mar=c(3,4,1,1), bty='n')
  MS_final = arrange(MS_final, L_mean)
  plot(1:nrow(MS_final), MS_final$L_mean,
       col = mycols_drugs[MS_final$Drug], 
       pch=20, cex=.3, yaxt='n', ylab='')
  axis(2, at = c(0,.5,1))
  polygon(c(1:nrow(MS_final), rev(1:nrow(MS_final))), 
          y = c(MS_final$L_lower,
                rev(MS_final$L_upper)), 
          border = NA, col = rgb(1, 0, 0,0.5))
  points(1:nrow(MS_final), MS_final$L_mean, 
         col = mycols_drugs[MS_final$Drug], 
         pch=20, cex=.5)
  mtext(side = 1, text = 'Recurrence index', line = 2)
  mtext(side = 2, text = 'Relapse probability', line = 3,las=3)
  legend('bottomright', col = mycols_drugs[2:3], 
         pch = 20, cex = 1.3, bty = 'n', 
         legend = c('No radical cure','Radical cure'))
  
  plot(MS_final$timeSinceLastEpisode, MS_final$L_mean,
       col = mycols_drugs[MS_final$Drug], 
       pch=20, cex=.51, xlab = '',yaxt='n',
       ylab = '')
  axis(2, at = c(0,.5,1))
  for(i in 1:nrow(MS_final)){
    
    if(abs(MS_final$L_upper[i] - MS_final$L_lower[i]) > 0.005){
      arrows(x0 = MS_final$timeSinceLastEpisode[i],
             y0 = MS_final$L_lower[i],
             x1=MS_final$timeSinceLastEpisode[i],
             y1 = MS_final$L_upper[i],
             length = 0.02,angle = 90, 
             code = 3,
             col=mycols_drugs[MS_final$Drug[i]])
    }
    i=i+1
  }
  mtext(side = 1, text = 'Days since last episode', line = 2)
  mtext(side = 2, text = 'Relapse probability', line = 3,las=3)
}
```
Individuals who appear to relapse very late (more than 300 days after last episode):
```{r}
MS_pooled = reformat_MSdata(MS_pooled)
IDs_late_relapse = MS_final[which(MS_final$timeSinceLastEpisode>300 & MS_final$L_lower>.9),'ID']

writeLines(sprintf('The episode ids of interest are: %s',
                   MS_final[which(MS_final$timeSinceLastEpisode>300 & MS_final$L_lower>.9),
                            'Episode_Identifier']))

# This isn't working on my Mac
#ColorPlot_MSdata(MS_data = MS_pooled[MS_pooled$ID%in%IDs_late_relapse,])
print(MS_pooled[MS_pooled$ID%in%IDs_late_relapse,])
```


The summaries of the final dataset:
```{r}
table(MS_final$Drug[!duplicated(MS_final$ID)]) # James, this sums to 159 - surely should sum to 164? Have we lost 5 people somewhere? 
# Yes: gotten rid of the 5 people who don't have recurrent episodes

ind_CQ = MS_final$Drug==2
writeLines(sprintf('In chloroquine monotherapy individuals, the weighted average of relapses is %s (%s-%s)',
                   round(100*sum(MS_final$L_mean[ind_CQ])/sum(ind_CQ),1),
                   round(100*sum(MS_final$L_lower[ind_CQ])/sum(ind_CQ),1),
                   round(100*sum(MS_final$L_upper[ind_CQ])/sum(ind_CQ),1)))

writeLines(sprintf('In chloroquine monotherapy individuals, the weighted average of recrudescences is %s (%s-%s)',
                   round(100*sum(MS_final$C_mean[ind_CQ],na.rm=T)/sum(ind_CQ),1),
                   round(100*sum(MS_final$C_lower[ind_CQ],na.rm=T)/sum(ind_CQ),1),
                   round(100*sum(MS_final$C_upper[ind_CQ],na.rm=T)/sum(ind_CQ),1)))

writeLines(sprintf('In chloroquine monotherapy individuals, the weighted average of reinfections is %s (%s-%s)',
                   round(100*sum(MS_final$I_mean[ind_CQ],na.rm=T)/sum(ind_CQ),1),
                   round(100*sum(MS_final$I_lower[ind_CQ],na.rm=T)/sum(ind_CQ),1),
                   round(100*sum(MS_final$I_upper[ind_CQ],na.rm=T)/sum(ind_CQ),1)))


ind_PMQ = MS_final$Drug==3
writeLines(sprintf('In chloroquine+primaquine individuals, the weighted average of relapses is %s (%s-%s)',
                   round(100*sum(MS_final$L_mean[ind_PMQ])/sum(ind_PMQ),1),
                   round(100*sum(MS_final$L_lower[ind_PMQ])/sum(ind_PMQ),1),
                   round(100*sum(MS_final$L_upper[ind_PMQ])/sum(ind_PMQ),1)))

writeLines(sprintf('In chloroquine+primaquine individuals, the weighted average of recrudescences is %s (%s-%s)',
                   round(100*sum(MS_final$C_mean[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   round(100*sum(MS_final$C_lower[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   round(100*sum(MS_final$C_upper[ind_PMQ],na.rm=T)/sum(ind_PMQ),1)))

writeLines(sprintf('In chloroquine+primaquine individuals, the weighted average of reinfections is %s (%s-%s)',
                   round(100*sum(MS_final$I_mean[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   round(100*sum(MS_final$I_lower[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   round(100*sum(MS_final$I_upper[ind_PMQ],na.rm=T)/sum(ind_PMQ),1)))

```


# False positive rate of relapse

We want to know how often our model estimates evidence of relapse across pairs of episodes when the episodes are in different people (e.g.)

```{r}
if(RUN_MODELS_FALSE_POSITIVE){
  # check if the massive pairwise dataset has been made, if not make it 
  # (takes a long time ~20hours)
  if(!"APC_MS_data.bigRData"%in%list.files()){
    # The pooled MS data from BPD and VHX
    load('../RData/GeneticModel/MS_data_PooledAnalysis.RData')
    tic()
    APC_MS_data = Make_All_Pairwise_Comparisons(MS_data = MS_pooled, ncores=42)
    save(APC_MS_data, file = 'APC_MS_data.bigRData')
    toc()
  } 
  load('APC_MS_data.bigRData')
  print('The inflated pairwise dataset is available, now running the analysis...')
  # Run the genetic model on the pairwise data
  tic()
  Inflated_Results = post_prob_CLI(MS_data = APC_MS_data, 
                                   Fs = Fs_Combined, 
                                   UpperComplexity = 10^6, 
                                   verbose = F,
                                   cores = 42)
  toc()
  save(Inflated_Results, file = 'Inflated_Results.bigRData')
} else {
  # load('Inflated_Results.bigRData')
  # load('APC_MS_data.bigRData')
}
```


# Analysis of radical cure efficacy in BPD

Almost all episodes in BPD were typed. Therefore we can estimate the true efficacy comparing with historical controls (VHX).

```{r}
#BPD_data = Combined_Time_Data[grep('BPD', Combined_Time_Data$patientid),]
# hist(table(BPD_data$patientid),breaks = seq(0.5,3.5,by=1),main='',
#      xlab = '', xaxt='n')
# axis(1, at = 1:3, labels = c('Enrollment\nonly','1\nrecurrence','2\nrecurrences'),
#      tick = FALSE)

Combined_Time_Data$Episode_Identifier = apply(Combined_Time_Data,1,
                                              function(x){
                                                paste(x['patientid'],as.integer(x['episode']),
                                                      sep='_')} )

# iterate over every episode and use either the joint posterior 
# or if missing the time probability (this could be time censored probability)
Combined_Time_Data$Reinfection_Probability=
  Combined_Time_Data$Reinfection_Probability_LL=
  Combined_Time_Data$Reinfection_Probability_UL = NA

Mod3_ThetaEstimates$Failure_Identifier = 
  apply(Mod3_ThetaEstimates, 1, 
        function(x) paste(x['patientid'], as.integer(x['episode'])-1,sep='_'))

sss=0
for(i in 1:nrow(Combined_Time_Data)){
  ep_id = Combined_Time_Data$Episode_Identifier[i]
  MS_id = paste(Combined_Time_Data$patientid[i],
                as.integer(Combined_Time_Data$episode[i])+1, sep='_')
  # If in MS_final then use full probability
  if(MS_id %in% MS_final$Episode_Identifier){
    Combined_Time_Data$Reinfection_Probability[i] =
      MS_final$I_mean[MS_final$Episode_Identifier==MS_id]
    Combined_Time_Data$Reinfection_Probability_UL[i] =
      MS_final$I_upper[MS_final$Episode_Identifier==MS_id]
    Combined_Time_Data$Reinfection_Probability_LL[i] =
      MS_final$I_lower[MS_final$Episode_Identifier==MS_id]
  } else { # use the time to event model
    ind = which(Mod3_ThetaEstimates$Failure_Identifier==ep_id)
    if(length(ind)>0){
      Combined_Time_Data$Reinfection_Probability[i] =
        Mod3_ThetaEstimates$ReInfection_mean_theta[ind]
      Combined_Time_Data$Reinfection_Probability_UL[i] =
        Mod3_ThetaEstimates$ReInfection_975_theta[ind]
      Combined_Time_Data$Reinfection_Probability_LL[i] =
        Mod3_ThetaEstimates$ReInfection_025_theta[ind]
      sss=sss+1
    }
  }
}
```


Now we look at whether the PK (carboxy-primaquine) can predict failure:
First we add the carboxy to the dataset:
```{r}
Combined_Time_Data = arrange(Combined_Time_Data, patientid, episode)
load('../RData/PK_data/BPD_pk.RData')
BPD_pk = filter(BPD_pk, !is.na(Episode))
Combined_Time_Data$log10_carboxyPMQ = NA
Combined_Time_Data$log10_PMQ = NA
Combined_Time_Data$NumberDaysPMQ = 14
for(i in 1:nrow(Combined_Time_Data)){
  id = Combined_Time_Data$patientid[i]
  ep_i = Combined_Time_Data$episode[i]
  all_id_eps = Combined_Time_Data$episode[Combined_Time_Data$patientid==id]
  pk_ind = which(BPD_pk$ID == id & BPD_pk$Episode==ep_i)
  if(length(pk_ind)>0){
    if(length(pk_ind)>1) print(id)
    Combined_Time_Data$log10_carboxyPMQ[i] = mean(BPD_pk$log10_carboxyPQ_PK[pk_ind])
    Combined_Time_Data$log10_PMQ[i] = mean(BPD_pk$log10_PQ_PK[pk_ind])
    Combined_Time_Data$NumberDaysPMQ[i] = BPD_pk$NumberofPKDays[pk_ind[1]]
  }
}
```

We exclude the two recurrences seen in patient BPD_444

```{r CarboxyPredictionFailure}
# These are two outliers - have discussed with Cindy
BPD444_recurrences = Combined_Time_Data$patientid=='BPD_44' & Combined_Time_Data$episode>1
BPD_598 = which(Combined_Time_Data$patientid=='BPD_598')
ind_keep = !BPD444_recurrences #& !BPD_598
require(lme4)
Combined_Time_Data$Failure_YN = Combined_Time_Data$Reinfection_Probability < 0.5
mod = glmer(Failure_YN ~ log10_carboxyPMQ + NumberDaysPMQ + 
              (1 | patientid), 
            family = 'binomial', data=Combined_Time_Data[ind_keep,])
summary(mod)
# Plot the data and model
xs=seq(0,4,by=.01)
par(las = 1, bty='n')
plot(Combined_Time_Data$log10_carboxyPMQ[ind_keep]*Combined_Time_Data$NumberDaysPMQ[ind_keep],
     Combined_Time_Data$Failure_YN[ind_keep], 
     col = mapvalues(Combined_Time_Data$NumberDaysPMQ[ind_keep],c(7,14),c(2,4)),
     pch = mapvalues(Combined_Time_Data$NumberDaysPMQ[ind_keep],c(7,14),c(3,4)),
     xlab = 'Primaquine trough exposure: days * log(ng/mL)',
     ylab = 'Probability of failure')
legend(x = 40, y = 0.3, bty='n', col =c(2,4), pch=c(3,4), legend = c('7 days','14 days'))
lines(xs*7, predict(mod, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=7,
                                            patientid='new'),allow.new.levels=T,
                    type='response'), lwd=2, col= 2, lty=2)
lines(xs*14, predict(mod, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=14,
                                             patientid='new'),allow.new.levels=T,
                     type='response'), lwd=2, col= 4, lty = 2)
points(Combined_Time_Data$log10_carboxyPMQ[BPD_598]*Combined_Time_Data$NumberDaysPMQ[BPD_598],
       Combined_Time_Data$Failure_YN[BPD_598], cex=2)
text(Combined_Time_Data$log10_carboxyPMQ[BPD_598[1]]*
       Combined_Time_Data$NumberDaysPMQ[BPD_598[1]]+3,
     Combined_Time_Data$Failure_YN[BPD_598[1]]-0.05, labels = 'BPD_598')
```

Now we remove outliers and fit the same model (CPMQ outliers)
```{r}
mu_hat_7 = mean(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==7])
sd_hat_7 = sd(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==7])
mu_hat_14 = mean(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==14],na.rm=T)
sd_hat_14 = sd(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==14],na.rm=T)

par(mfrow=c(1,2))
hist(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==7],
     main='', xlab='carboxy primaquine day 7 (ng/mL)')
abline(v = mu_hat_7 - sd_hat_7*3)

hist(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==14],
     main = '', xlab='carboxy primaquine day 7 (ng/mL)')
abline(v = mu_hat_14 - sd_hat_14*3)

outliers7 = Combined_Time_Data$NumberDaysPMQ==7 & Combined_Time_Data$log10_carboxyPMQ<mu_hat_7 - sd_hat_7*3
outliers14 = Combined_Time_Data$NumberDaysPMQ==14 & Combined_Time_Data$log10_carboxyPMQ<mu_hat_14 - sd_hat_14*3

mod_No_Outliers = glmer(Failure_YN ~ log10_carboxyPMQ + NumberDaysPMQ + 
                          (1 | patientid), 
                        family = 'binomial', data=Combined_Time_Data[ind_keep & !outliers14 & !outliers7,])
summary(mod_No_Outliers)
```

Compare results with and without outliers:

```{r CarboxyPredictionFailure_NoOutliers}
par(las = 1, bty='n')
plot(Combined_Time_Data$log10_carboxyPMQ[ind_keep]*Combined_Time_Data$NumberDaysPMQ[ind_keep],
     Combined_Time_Data$Failure_YN[ind_keep], 
     col = mapvalues(Combined_Time_Data$NumberDaysPMQ[ind_keep],c(7,14),c(2,4)),
     pch = mapvalues(Combined_Time_Data$NumberDaysPMQ[ind_keep],c(7,14),c(3,4)),
     xlab = 'Primaquine trough exposure: days * log(ng/mL)',
     ylab = 'Probability of failure')
legend(x = 40, y = 0.3, bty='n', col =c(2,4), pch=c(3,4), legend = c('7 days','14 days'))
lines(xs*7, predict(mod, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=7,
                                            patientid='new'),allow.new.levels=T,
                    type='response'), lwd=2, col= 2, lty=2)
lines(xs*14, predict(mod, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=14,
                                             patientid='new'),allow.new.levels=T,
                     type='response'), lwd=2, col= 4, lty = 2)

lines(xs*7, predict(mod_No_Outliers, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=7,
                                                        patientid='new'),allow.new.levels=T,
                    type='response'), lwd=2, col= 2, lty=1)
lines(xs*14, predict(mod_No_Outliers, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=14,
                                                         patientid='new'),allow.new.levels=T,
                     type='response'), lwd=2, col= 4, lty = 1)

# outline the outliers
points(Combined_Time_Data$log10_carboxyPMQ[outliers14|outliers7]*Combined_Time_Data$NumberDaysPMQ[outliers14|outliers7],
       Combined_Time_Data$Failure_YN[outliers14|outliers7], cex=2)
```

Now we calculate a compressed dataset and failure for each individual

```{r}
# now we calculate the primaquine failure rate
# For individuals with two episodes: P(failure) = 1 - P(Rec 1 = I)*P(Rec 2 = I)
Summary_data = Combined_Time_Data[!duplicated(Combined_Time_Data$patientid),]
Summary_data$Failure_UL = Summary_data$Failure_LL = 
  Summary_data$Failure = Summary_data$CPMQ = 
  Summary_data$CPMQ = NA
for(i in 1:nrow(Summary_data)){
  ind = which(Combined_Time_Data$patientid==Summary_data$patientid[i])
  Summary_data$Failure[i] = 1-prod(Combined_Time_Data$Reinfection_Probability[ind],na.rm=T)
  Summary_data$Failure_UL[i] = 1-prod(Combined_Time_Data$Reinfection_Probability_UL[ind],na.rm=T)
  Summary_data$Failure_LL[i] = 1-prod(Combined_Time_Data$Reinfection_Probability_LL[ind],na.rm=T)
  Summary_data$CPMQ[i] = median(Combined_Time_Data$log10_carboxyPMQ[ind],na.rm=T)
}
BPD_data = Summary_data[grep('BPD', Summary_data$patientid),]

P_Failure=100*sum(BPD_data$Failure)/nrow(BPD_data)
# invert the intervals here - optimistic for not failure = pessimistic for failure
P_Failure_UL = 100*sum(BPD_data$Failure_LL)/nrow(BPD_data)
P_Failure_LL = 100*sum(BPD_data$Failure_UL)/nrow(BPD_data)

writeLines(sprintf('The primaquine failure rate in the %s individuals is %s%% (%s-%s) over the course of %s years total follow-up.',
                   nrow(BPD_data), round(P_Failure,2),
                   round(P_Failure_LL,2),
                   round(P_Failure_UL,2), round(sum(BPD_data$FU_time)/365)))
```


This won't go into this paper but looking out of interest:

Does 2D6 correlate with carboxy ?

```{r}
TwoD6_dat = read.csv('../RData/PK_data/TwoD6&Vivax Genotyping_ASscore.csv')
TwoD6_dat$ID = apply(TwoD6_dat, 1, function(x) paste(x['Study'],
                                                     as.integer(x['Patient.ID']),
                                                     sep = '_'))
TwoD6_dat$Phenotype = mapvalues(TwoD6_dat$X2D6.Phenotype, 
                                from = c('PM','IM', 'EM'), to = 1:3)
Combined_Time_Data$Phenotype = Combined_Time_Data$ASscore = NA
for(i in 1:nrow(Combined_Time_Data)){
  id = Combined_Time_Data$patientid[i]
  if(sum(TwoD6_dat$ID==id)>0){
    Combined_Time_Data$ASscore[i] = TwoD6_dat$AS.score[TwoD6_dat$ID==id]
    Combined_Time_Data$Phenotype[i] = TwoD6_dat$Phenotype[TwoD6_dat$ID==id]
  }
}

mod_2D6 = lmer(log10_carboxyPMQ ~ ASscore + NumberDaysPMQ + (1 | patientid), 
               data = Combined_Time_Data)
summary(mod_2D6)
plot(Combined_Time_Data$ASscore, Combined_Time_Data$log10_carboxyPMQ, pch=20)
lines(xs, predict(mod_2D6, data.frame(ASscore=xs,NumberDaysPMQ=7,patientid='new'),allow.new.levels=T),lwd=3)
```


```{r}
Combined_2D6data = filter(Combined_Time_Data, !is.na(ASscore), !Censored)
for(id in unique(Combined_2D6data$patientid)){
  ind = Combined_2D6data$patientid==id
  Combined_2D6data$Failure_YN[ind] = max(Combined_2D6data$Failure_YN[ind])
}
Combined_2D6data = Combined_2D6data[!duplicated(Combined_2D6data$patientid),]
mod_Failure = glm(Failure_YN ~ ASscore, 
                  data = Combined_2D6data, family = 'binomial')
summary(mod_Failure)
```


