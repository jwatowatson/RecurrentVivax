---
title: "Pooled Analysis"
author: "Aimee Taylor and James Watson"
output:
  pdf_document: default
  html_document:
    df_print: paged
    keep_md: yes
---

# Preamble

Load R packages, functions and data.

```{r, echo=FALSE, include=FALSE}
#==========================================================================
# Set up
#==========================================================================
knitr::opts_chunk$set(cache = F, cache.comments = FALSE, 
                      include = TRUE, 
                      fig.width = 7, fig.height = 7,
                      fig.pos = 'H', 
                      dev = 'png', dpi = 300)

rm(list = ls())
load('../RData/RPackages_List.RData')
new.pkg <- pkgs[!(pkgs %in% installed.packages()[, "Package"])]
if(length(new.pkg) > 0){ # Install using .R script
  stop('Please run the script Install_and_load_required_packages.R before returning to this script. Thanks.')
}else{
  sapply(pkgs, require, character.only = TRUE) # Load all packages
}
tic()
load('../RData/TimingModel/MOD2_theta_estimates.RData')
load('../RData/TimingModel/MOD2_Posterior_samples.RData')
load('../RData/TimingModel/Combined_Time_Event.RData')

source("../Genetic_Model/Data_functions.R")
source('../Genetic_Model/iGraph_functions.R')
source("../Genetic_Model/post_prob_CLI.R") 
source("../Genetic_Model/test_Rn_compatible.R") 
source("../Genetic_Model/Data_Inflation_Functions.R")
source("../Genetic_Model/hap_combinations_functions.R")

# The pooled MS data from BPD and VHX
load('../RData/GeneticModel/MS_data_PooledAnalysis.RData')

# Vector of states
states = c(relapse = 'L', reinfection = 'I', recrudescence = 'C')

# Convert to data.frame since there are some odd bugs associate with tibble...
# https://stackoverflow.com/questions/39041115/fixing-a-multiple-warning-unknown-column
Combined_Time_Data = as.data.frame(Combined_Time_Data)

## Threshold value for classification
Epsilon_upper = 0.7
Epsilon_lower = 0.3

# For credible interval calculations
lowerCI=0.025
upperCI=0.975

# Colour scheme
# For colourblind friendly: display.brewer.all(colorblindFriendly = T)
Dark2 = brewer.pal(8, 'Dark2')
drug_cols2 = array(Dark2[c(2,2,1)], dim = 3, dimnames = list(c('AS','CHQ','CHQ/PMQ')))
drug_cols_light2 = sapply(drug_cols2, adjustcolor, alpha.f = 0.5)
transparent_blue_band = adjustcolor('blue', alpha.f = 0.1)

Ncores = 6 # number of cores to use for model estimation

#---------------------------------------------------------------------------------------------
# Booleans that describe generation of Markdown file 
# The large jobs should be done on the cluster
#---------------------------------------------------------------------------------------------
EXCLUDE_COMPLEX = F # There are 9 patients with complex data that considerably increase computation time
if(EXCLUDE_COMPLEX) {
  f_name_prefix = '../RData/GeneticModel/Excluding_Complex_Cases' 
  Ksamples_min = 100 # Number of random draws from the {time-to-event, allele frequency} prior that informs the CI around geneticallt informed estimate
} else{ 
  f_name_prefix = '../RData/GeneticModel/Including_Complex_Cases'
  Ksamples_min = 10 
}

# runs the model for 100 random draws from the Time model posterior on those that can be directly computed
RUN_MODELS_FULL_POSTERIOR = F #

# runs time-agnostic (with random draws from  allele frequency distribution) 
# whose output used for genetic only efficacy estimate
RUN_MODELS_FULL_POSTERIOR_TAGNOSTIC = F 

# runs the model for 100 random draws from the Time model posterior on those that cannot be directly computed
RUN_MODELS_FULL_POSTERIOR_INFLATED = F

# Does the false positive discovery estimation
RUN_MODELS_FALSE_POSITIVE = F # 13 hours to run

# generates plots
CREATE_PLOTS = T
```

```{r}
#============================================================
# First let's extract some summaries and format the data frames 
# ahead of summaries and analyses
#============================================================
total_patient_names = unique(Combined_Time_Data$patientid)
total_patient_count = length(total_patient_names)

# Add a variable with trial, drug arm (if VHX) and partner (if BPD - since drug arm was labelled CQ for all BPD for modelling purpose)
ind_VHX_ctd = grepl('VHX', Combined_Time_Data$patientid)
Combined_Time_Data$trial_arm_partner = NA
Combined_Time_Data$trial_arm_partner[ind_VHX_ctd] = paste('VHX', Combined_Time_Data$arm_num[ind_VHX_ctd])
Combined_Time_Data$trial_arm_partner[!ind_VHX_ctd] = paste('BPD', Combined_Time_Data$PMQ_partner[!ind_VHX_ctd])

# Note that Combined_Time_Data has censored rows for patients
Combined_Time_Data_no_cnsd_rows = Combined_Time_Data[Combined_Time_Data$Censored != 1,] # remove censored rows
uncensored_patientid_vector = Combined_Time_Data_no_cnsd_rows$patientid # vector of patientids excluding censored rows (inc. duplicates)

# names of patients who recurred
recur_patient_names = names(which(table(uncensored_patientid_vector) > 1))

# Treatment of all those who recurred
recur_patient_treatment = sapply(recur_patient_names, function(id){
  inds = Combined_Time_Data$patientid == id
  treatment = unique(Combined_Time_Data$trial_arm_partner[inds])
  if(length(treatment) >1){stop('More than one treatment')}else{treatment}
  })

# Number of episodes per persons 
All_VHX_epi_count = table(uncensored_patientid_vector[grepl('VHX_',uncensored_patientid_vector)]) 
All_BPD_epi_count = table(uncensored_patientid_vector[grepl('BPD_',uncensored_patientid_vector)]) 

# Add trial, drug arm (if VHX) and partner (if BPD - see above) to genetic data 
MS_pooled$trial_arm_partner = sapply(1:nrow(MS_pooled), function(i){unique(Combined_Time_Data$trial_arm_partner[Combined_Time_Data$patientid==MS_pooled$ID[i]])})

# Collapse rows due to complex infections (COI > 2)
MS_pooled_summary = MS_pooled[!duplicated(MS_pooled$Episode_Identifier),] 
```


# Summary of the clinical trial data (features in Table 1 of the main text)

```{r, echo=FALSE}
treatment_order = c("VHX AS", "VHX CHQ", "VHX CHQ/PMQ", "BPD CHQ", "BPD DP") # Note: all BPD received PMQ        

writeLines(sprintf('\nNumber of patients: %s (%s in VHX; %s in BPD)', total_patient_count, 
                   length(All_VHX_epi_count), length(All_BPD_epi_count)))

writeLines('\nNumber of patients by treatment:')
table(Combined_Time_Data$trial_arm_partner[!duplicated(Combined_Time_Data$patientid)])[treatment_order]

# XXX ADD SUMMARIES FOR SEX, AGE, FOLLOW UP, PARASITE DENSITIES XXX

writeLines('\nNumber of patients who recurred by treatment, Nr:') # XXX Why does VHX PMQ disagree???? 
table(recur_patient_treatment)[treatment_order]
Nr = table(recur_patient_treatment)[treatment_order]

writeLines('\nPercent of N patients who recurred by treatment:') # XXX Why does VHX PMQ disagree???? 
round(100*table(recur_patient_treatment)/length(recur_patient_treatment))[treatment_order]

writeLines('\nNumber of individuals with at least one episode typed by treatment:')
table(MS_pooled$trial_arm_partner[!duplicated(MS_pooled$ID)])[treatment_order]

writeLines('\nPercent of Nr individuals with at least one episode typed by treatment:') # XXX Why does VHX PMQ disagree???? 
round(100*table(MS_pooled$trial_arm_partner[!duplicated(MS_pooled$ID)])[names(Nr)]/Nr)[treatment_order]

recur_ind = MS_pooled$Episode > 1

writeLines('\nNumber of individuals with at least one recurrence typed by treatment:')
table(MS_pooled$trial_arm_partner[recur_ind][!duplicated(MS_pooled$ID[recur_ind])])[treatment_order]

writeLines('\nPercent of Nr individuals with at least one recurrence typed by treatment:') # XXX Why does VHX PMQ disagree???? 
round(100*table(MS_pooled$trial_arm_partner[recur_ind][!duplicated(MS_pooled$ID[recur_ind])])[names(Nr)]/Nr)[treatment_order]

# XXX ADD SUMMARIES FOR ANALYSED XXX

writeLines('\nNumber of recurrences by treatment:')
table(Combined_Time_Data_no_cnsd_rows$trial_arm_partner[Combined_Time_Data_no_cnsd_rows$episode > 1])[treatment_order]
R = table(Combined_Time_Data_no_cnsd_rows$trial_arm_partner[Combined_Time_Data_no_cnsd_rows$episode > 1])[treatment_order]
  
writeLines('\nNumber of recurrences typed by treatment:')
table(MS_pooled_summary$trial_arm_partner[MS_pooled_summary$Episode > 1])[treatment_order]

writeLines('\nPercent of R recurrences typed by treatment:')
round(100*table(MS_pooled_summary$trial_arm_partner[MS_pooled_summary$Episode > 1])[names(R)]/R)[treatment_order]

# XXX ADD SUMMARIES FOR ANALYSED XXX

# Some extra summaries
writeLines(sprintf('\n\nFrom BPD trial there are %s individuals with total of %s episodes typed (enrollment: %s; recurrent %s)',
                   length(unique(MS_pooled$ID[grep('BPD',MS_pooled$ID)])),
                   length(unique(MS_pooled$Episode_Identifier[grep('BPD',MS_pooled$ID)])), 
                   length(unique(MS_pooled[grepl('BPD',MS_pooled$ID) & MS_pooled$Episode == 1,
                                           'Episode_Identifier'])), 
                   length(unique(MS_pooled[grepl('BPD',MS_pooled$ID) & MS_pooled$Episode > 1,
                                           'Episode_Identifier']))))


writeLines(sprintf('From VHX trial there are %s individuals with total of %s episodes typed (enrollment: %s; recurrent %s)',
                   length(unique(MS_pooled$ID[grep('VHX',MS_pooled$ID)])),
                   length(unique(MS_pooled$Episode_Identifier[grep('VHX',MS_pooled$ID)])),
                   length(unique(MS_pooled[grepl('VHX',MS_pooled$ID) & MS_pooled$Episode == 1, 'Episode_Identifier'])), 
                   length(unique(MS_pooled[grepl('VHX',MS_pooled$ID) & MS_pooled$Episode > 1, 'Episode_Identifier']))))
```

# Next we summarise the number of episodes typed in people with one or more episodes typed

```{r}
#=================================================================
# Number of episodes typed conditional on a person being selected for genotyping
#=================================================================
# No. of typed episodes per person with one or more typed episodes in VHX and BPD
no_of_typed_epi_per_person_typed_VHX = table(MS_pooled_summary$ID[grepl('VHX',MS_pooled_summary$ID)])  
no_of_typed_epi_per_person_typed_BPD = table(MS_pooled_summary$ID[grepl('BPD',MS_pooled_summary$ID)])  

# No. of total episodes per person with one or more typed episodes in VHX and BPD
no_of_epi_per_person_typed_VHX = All_VHX_epi_count[names(All_VHX_epi_count) %in% names(no_of_typed_epi_per_person_typed_VHX)]
no_of_epi_per_person_typed_BPD = All_BPD_epi_count[names(All_BPD_epi_count) %in% names(no_of_typed_epi_per_person_typed_BPD)]

#-------------------------
# VHX data set summary: brief because genotyping VHX was not exhaustive
#-------------------------
X0 = length(no_of_typed_epi_per_person_typed_VHX) # Number of people typed
ind_untyped = no_of_epi_per_person_typed_VHX != no_of_typed_epi_per_person_typed_VHX
X1 = sum(ind_untyped) # Number of people selected for genotyping but some episodes untyped
# How many untyped per person with incomplete set of episodes typed:
X2 = range(no_of_epi_per_person_typed_VHX[ind_untyped] - no_of_typed_epi_per_person_typed_VHX[ind_untyped]) 
X3 = sum(no_of_epi_per_person_typed_VHX - no_of_typed_epi_per_person_typed_VHX) # Total number untyped
writeLines(sprintf('\nVHX: for %s of %s VHX individual/s selected for genotyping: %s to %s of their episodes were not typed (total of %s episodes untyped summing over the %s individuals)',X1,X0,X2[1],X2[2],X3,X1))

# How about for those who received PMQ in VHX? 
no_of_typed_epi_per_person_typed_VHX_PMQ = table(MS_pooled_summary$ID[MS_pooled_summary$trial_arm_partner == "VHX CHQ/PMQ"])
no_of_epi_per_person_typed_VHX_PMQ = All_VHX_epi_count[names(All_VHX_epi_count) %in% names(no_of_typed_epi_per_person_typed_VHX_PMQ)]
X0 = length(no_of_typed_epi_per_person_typed_VHX_PMQ) # Number of people typed
ind_untyped = no_of_epi_per_person_typed_VHX_PMQ != no_of_typed_epi_per_person_typed_VHX_PMQ
X1 = sum(ind_untyped) # Number of people selected for genotyping but some episodes untyped
# How many untyped per person with incomplete set of episodes typed:
X2 = range(no_of_epi_per_person_typed_VHX_PMQ[ind_untyped] - no_of_typed_epi_per_person_typed_VHX_PMQ[ind_untyped]) 
X3 = sum(no_of_epi_per_person_typed_VHX_PMQ - no_of_typed_epi_per_person_typed_VHX_PMQ) # Total number untyped
writeLines(sprintf('\nVHX: for %s of %s PMQ+ treated VHX individual/s selected for genotyping: %s to %s of their episodes were not typed (total of %s episodes untyped summing over the %s individuals)',X1,X0,X2[1],X2[2],X3,X1))
PMQ_treated_VHX_ids = names(no_of_typed_epi_per_person_typed_VHX_PMQ)

#-------------------------
# BPD data set: comprehensive because genotyping BPD was exhaustive
#-------------------------
# How many people who experience one or more recurrences had one or more episodes genotyped? 
recurrences = All_BPD_epi_count[All_BPD_epi_count > 1]-1
indivs_who_recurred = names(recurrences)
indivs_who_were_typed = names(no_of_typed_epi_per_person_typed_BPD)
indivs_who_were_not_typed = indivs_who_recurred[!indivs_who_recurred %in% indivs_who_were_typed]

# Summary over individuals typed 
X0 = length(indivs_who_were_typed) # Number of people typed
ind_untyped = no_of_epi_per_person_typed_BPD != no_of_typed_epi_per_person_typed_BPD
X1 = sum(ind_untyped) # Number of episodes untyped
# How many untyped per person with incomplete set of episodes typed:
X2 = range(no_of_epi_per_person_typed_BPD[ind_untyped] - no_of_typed_epi_per_person_typed_BPD[ind_untyped])  
X3 = sum(no_of_epi_per_person_typed_BPD - no_of_typed_epi_per_person_typed_BPD)  # Total number untyped

# Individuals with not all episodes typed
ind_missing_typed_epi <- names(which(no_of_epi_per_person_typed_BPD != no_of_typed_epi_per_person_typed_BPD)) 

# All episodes of the BPD individuals missing one or episodes
X4 = lapply(ind_missing_typed_epi, function(x){
  ind = grepl(x, uncensored_patientid_vector)
  Combined_Time_Data_no_cnsd_rows$episode[ind]
})

# Typed episodes of the BPD individuals missing one or episodes
X5 = lapply(ind_missing_typed_epi, function(x){
  ind = grepl(x, MS_pooled_summary$ID)
  MS_pooled_summary$Episode[ind]
})

X6 = lapply(1:length(X5), function(i){setdiff(X4[[i]], X5[[i]])}) # Not typed episodes
X7 = sum(sapply(X6, function(x)sum(x>1))) # Not typed recurrence

writeLines(paste(sprintf('\nBPD: of %s of the people who recurred: %s person/people with %s recurrence/s was not selected for genotyping.',
                         length(unique(indivs_who_recurred)), 
                         length(unique(indivs_who_were_not_typed)), 
                         recurrences[indivs_who_were_not_typed]), 
                 sprintf('Of %s of %s BPD individual/s selected for genotyping: %s to %s of their episodes were not typed (%s episodes summing over the %s individuals).', X1,X0,X2[1],X2[2],X3,X1), 
                 sprintf('Of the %s episodes not typed %s were recurrences.',X3, X7),
                 sprintf('In total there were %s recurrences: %s untyped.', sum(recurrences), recurrences[indivs_who_were_not_typed] + X7)))
```

These findings are summarised in the following plot.  

```{r, echo=FALSE}
# Plot of episodes versus total numbers of episodes per person selected for genotyping
par(mfrow = c(1,2), family = 'serif', pty = 's') 
# Cols to highlugh PMQ_VHX (ooints of interest are overlaid so not worth showing)
cols_PMQ_VHX = ifelse(names(no_of_epi_per_person_typed_VHX) %in% PMQ_treated_VHX_ids, 'darkgreen', 'black')
plot(x = as.numeric(no_of_epi_per_person_typed_VHX), y = as.numeric(no_of_typed_epi_per_person_typed_VHX), 
     xlab = 'Number of episodes per person', ylab = 'Number of typed episodes per person', main = 'VHX',
     ylim = range(no_of_epi_per_person_typed_VHX), xlim = range(no_of_epi_per_person_typed_VHX))
abline(a = 0, b = 1, lty = 'dotted')
plot(x = as.numeric(no_of_epi_per_person_typed_BPD), 
     y = as.numeric(no_of_typed_epi_per_person_typed_BPD), 
     xlab = 'Number of episodes per person', ylab = 'Number of typed episodes per person', main = 'BPD',
     ylim = range(no_of_epi_per_person_typed_VHX), xlim = range(no_of_epi_per_person_typed_VHX)) # Match range to VHX
abline(a = 0, b = 1, lty = 'dotted')
```


```{r VHX_typed_untyped}
#=================================================================
# Visual check of difference in episode counts between VHX 
# that where genetically typed and not
#=================================================================
# Condition on CQ since these were the ones selected for genotyping 
CQ_ind_epi <- Combined_Time_Data_no_cnsd_rows$arm_num == "CHQ" 
# vector of patientids excluding censored rows and those without CQ
uncensored_patientid_vector = Combined_Time_Data_no_cnsd_rows$patientid[CQ_ind_epi] 
# Number of episodes per person VHX
All_VHX_epi_count = table(uncensored_patientid_vector[grepl('VHX_',uncensored_patientid_vector)]) 

# Condition on those that have one or more recurrence
All_VHX_rec_count = All_VHX_epi_count[All_VHX_epi_count > 1] 
x1 = no_of_epi_per_person_typed_VHX
x2 = All_VHX_rec_count[!names(All_VHX_rec_count) %in% names(x1)] # No of epi per person untyped
# setequal(names(x1), names(x2)) # Check mutually exclusive
# setequal(names(x2), unique(names(MS_pooled_summary$ID))) # Further check 
max_rec = max(All_VHX_rec_count)
```

```{r, echo=FALSE}
# Typed more heavy tailed
hist(x2, col = 'lightgray', freq = F, breaks = seq(0.5, max_rec+0.5, 1), ylim = c(0,0.35), 
     main='VHX subset', xlab = 'Number of episodes')
hist(x1, col = 'red', density = 15, add = T, freq = F, breaks = seq(0.5, max_rec+0.5, 1))
legend('topright', legend = c('Untyped', 'Typed'), fill =c('lightgray', 'red'),
       density = c(100,25), bty = 'n')
```

# Summary of complexity of infection (COI) based on numbers of alleles observed. 

This section is broken down by enrollment episodes (this is independent of drug given) and subsequent recurrences which could be drug dependent.

```{r COIs_VHX_BPD}
COIs = data.frame(t(sapply(unique(MS_pooled$Episode_Identifier), function(x){
  ind = which(MS_pooled$Episode_Identifier == x)
  c(MOI=max(MS_pooled$MOI_id[ind]),
    Enrollment = MS_pooled$Episode[ind[1]] == 1,
    Drug = MS_pooled$Treatment[ind[1]])
})))
COIs$MOI = as.numeric(COIs$MOI)
COIs$Enrollment = as.logical(COIs$Enrollment) # Converts factor to logical
COIs$PMQ = 0 
COIs$PMQ[!COIs$Enrollment & COIs$Drug=='PMQ']=1
```

```{r}
# XXX TAlk to James
# if we partition by receipt of PMQ and not under the hypothesis that if relapses are less diverse
# enrolment effect larger in partion who received PMQ: 
COIs$PMQ = ifelse(COIs$Drug=='PMQ',1,0)
mod1 = glm(MOI ~ enrollment, family = 'poisson', 
          data = data.frame(MOI= COIs$MOI - 1, # need to do minus 1 so it's Poisson appropriate
                            enrollment = as.numeric(COIs$Enrollment))[COIs$PMQ == 1,])
mod2 = glm(MOI ~ enrollment, family = 'poisson', 
           data = data.frame(MOI= COIs$MOI - 1, # need to do minus 1 so it's Poisson appropriate
                             enrollment = as.numeric(COIs$Enrollment))[COIs$PMQ != 1,])
summary(mod1)
summary(mod2)
# As it happens, opposite is true. Suggests to me the pattern in MOI might be to declining transmission
```

```{r, echo=FALSE}
par(las=1, mfrow=c(1,2))

# Distribution of enrollment COIs
hist(COIs$MOI[COIs$Enrollment], freq = F, breaks = seq(0.5,4.5, by=1),
     xlab = 'COIs', ylab = '% of enrollment episodes',
     main='Enrollment episodes', col = 'gray', 
     yaxt='n', ylim = c(0,.75))
axis(2, at = c(0,.25,.5,.75), labels = 100*c(0,.25,.5,.75))

# Distribution of recurrent COIs by drug
hist(COIs$MOI[!COIs$Enrollment & COIs$Drug=='PMQ'], freq = F, 
     breaks = seq(0.5,4.5, by=1),
     xlab = 'COIs', ylab = '% of enrollment episodes',
     yaxt='n', ylim = c(0,.75), main='Recurrent episodes ', 
     density = 15, angle = 30, col ='blue')
axis(2, at = c(0,.25,.5,.75), labels = 100*c(0,.25,.5,.75))
hist(COIs$MOI[!COIs$Enrollment & !COIs$Drug=='PMQ'], freq = F, 
     breaks = seq(0.5,4.5, by=1),
     xlab = 'COIs', ylab = '% of enrollment episodes',add=T,
     yaxt='n', ylim = c(0,.75), main='', density = 15, 
     angle = -30, col ='grey')
axis(2, at = c(0,.25,.5,.75), labels = 100*c(0,.25,.5,.75))
legend('topright',col=c('blue','grey'),legend = c('PMQ+','No PMQ'), lwd=2)
mod = glm(MOI ~ enrollment + drug, family = 'poisson', 
          data = data.frame(MOI=COIs$MOI - 1, # need to do minus 1 so it's Poisson appropriate
                            enrollment=as.numeric(COIs$Enrollment),
                            drug = COIs$PMQ))
summary(mod)
writeLines(sprintf('Mean complexity of recurrent episodes is %s, and mean complexity of enrollment episodes is %s',
                   round(1+exp(mod$coefficients['(Intercept)']),2),
                   round(1+exp(mod$coefficients['(Intercept)']+mod$coefficients['enrollment']),2)))

# Summary of median COI per study
BPD_ind = grepl('BPD_', rownames(COIs))
VHX_ind = grepl('VHX_', rownames(COIs))
writeLines(sprintf('Median COI in VHX and BPD: %s and %s, respectively',
                   median(COIs$MOI[VHX_ind]),median(COIs$MOI[BPD_ind])))

# Summary of COIs >= 3 (important due to computational complexity)
writeLines(sprintf('%s of %s episodes (%s percent) with COI greater than or equal to 3', 
                   sum(COIs$MOI >= 3), nrow(COIs), round(100*mean(COIs$MOI >= 3))))
```


From this Poisson regression, there appears to be evidence that enrollment episodes have higher complexities of infection than recurrences. This implies that relapses are more likely to be single hypnozoite activated infections? - XXXX 


# Allele frequencies

First we define the set of microsatellite markers used in this analysis:
```{r}
MSs_all = c("PV.3.502","PV.3.27","PV.ms8",
            "PV.1.501","PV.ms1","PV.ms5",
            "PV.ms6","PV.ms7","PV.ms16")
```

We use a multinomial-dirichlet model with subjective weight $\omega$. $\omega = 0$ recovers the empirical allele frequencies. 

```{r, echo=F}
# Prior weight for the Dirichlet (setting weight to 0 recovers empirical freq):
D_weight_Prior = 1

# These are motif lengths: for the plotting
MSs_Motifs = list("PV.3.502"=8,'PV.3.27' = 4, 
                  "PV.ms8" = 3, "PV.1.501"= 7, 
                  "PV.ms1" = 3, "PV.ms5" = 3,
                  "PV.ms6" = 3, "PV.ms16" =3,
                  "PV.ms7" = 3)

writeLines(paste('Number of episodes used to compute frequencies:',sum(MS_pooled_summary$Episode==1)))
Ind_Primary = which(MS_pooled$Episode==1)

# Posterior Dirichlet parameter vector
Alpha_Posteriors = apply(MS_pooled[,MSs_all], 2, function(x, Ind_Primary){
  # Extract xmax 
  xmax = max(x,na.rm=T)
  # prior parameter vector (iterpolates unobserved repeat lengths < xmax)
  param_vector = array(D_weight_Prior, dim = xmax, dimnames = list(1:xmax)) 
  # observed data summarised as counts
  obs_counts = table(x[Ind_Primary]) 
  # posterior parameter vector
  param_vector[names(obs_counts)] = param_vector[names(obs_counts)] + obs_counts
  return(param_vector)
})

# Calculate posterior mean 
Fs_Combined = sapply(Alpha_Posteriors, function(x){x/sum(x)})
```

```{r}
#==================================================================
# Save a data set of monoclonal data and allele frequencies for
# relatedness estimation (this was analysed elsewhere)
#==================================================================
monoclonal_names = rownames(COIs)[COIs$MOI == 1]
#monoclonal_data = MS_pooled[MS_pooled$Episode_Identifier%in%monoclonal_names, ]
# save(monoclonal_data, Fs_Combined, file = '../RData/Data_for_relatedness.RData')
```

Calculate the effective marker cardinality for each microsatellite marker using a simulation approach.

```{r}
N = 10^6
Effective_Allele_size = list()
for(ms in MSs_all){
  n_obs_alleles = length(table(MS_pooled[Ind_Primary,ms]))
  draw1 = sample(x = names(Fs_Combined[[ms]]), replace = T, size = N, prob = Fs_Combined[[ms]])
  draw2 = sample(x = names(Fs_Combined[[ms]]), replace = T, size = N, prob = Fs_Combined[[ms]])
  x = mean(draw1 == draw2)
  n = 1/x
  writeLines(sprintf('The effective cardinality for %s with %s observed alleles is %s', ms, n_obs_alleles, round(n,2)))
  Effective_Allele_size[[ms]] = round(n,1)
}
# The mean and range in our data set
writeLines(sprintf('The mean effective marker cardinality is %s, range: %s to %s', 
                   round(mean(unlist(Effective_Allele_size)),2), 
                   round(min(unlist(Effective_Allele_size)),2), 
                   round(max(unlist(Effective_Allele_size)),2)))

# Equivalent number of biallelic SNPs
sum(logb(unlist(Effective_Allele_size), base = 1.5)) # realistic SNPs
sum(logb(unlist(Effective_Allele_size), base = 2)) # ideal SNPs
```



## Plotting allele frequencies

These are the mean posterior allele frequencies (dots) and 95\% credible intervals (bars) given pooled enrollment data and $\omega=$ `D_weight_Prior`.

```{r AlleleFrequencies, echo=F}
if(CREATE_PLOTS){
  par(mfrow=c(3,3), las=1, bty='n', cex.axis=1.2, family = 'serif')
  for(ms in MSs_all){ # As bars
    K = length(Fs_Combined[[ms]]) # Cardinality of ms 
    xs = rdirichlet(n = 1000, alpha = Alpha_Posteriors[[ms]]) # Sample from posterior
    # MC approximation of 0.975 percentile expressed as percentage
    YMAX = max(apply(xs, 2, quantile, probs = .975)) # Round up to nearest decimal
    # Number of observations
    N_MS = length(unique(MS_pooled$ID[MS_pooled$Episode==1 & !is.na(MS_pooled[,ms])]))
    plot(NULL, panel.first = grid(),
         main = sprintf('%s', ms), font.main = 3, 
         pch = 18, ylim=c(0,YMAX), xlim = c(1,ncol(xs)), 
         ylab='', xlab='', yaxt='n')
    
    abline(h=1/K, lty = 'dashed', lwd = 1)
    title(ylab='Frequency', line = 3.25)
    title(xlab= sprintf('Repeat length (motif length = %s)', MSs_Motifs[[ms]]), line = 2.5)
    # made the number of individuals N: same as appendix notation
    mtext(side = 3, text = sprintf('(N = %s)',N_MS), line = 0.5, cex = 0.65, adj = 0)
    mtext(side = 3, text = sprintf('(n* = %s)',Effective_Allele_size[[ms]]), 
          line = 0.5, cex = 0.65, adj = 1)
    for(k in 1:ncol(xs)){
      lines(rep(k,2), quantile(xs[,k],probs = c(0.025,0.975)))
    }
    points(1:length(Fs_Combined[[ms]]),Fs_Combined[[ms]],pch=18) # Point estimates: mean 
    axis(2, round(seq(0, round(YMAX,2), length.out = 3),2))
  }
}
```

# Summaries of samples selected to be genotyped at additional 6 markers 

```{r}
# Extract MS names
MS_core = MSs_all[1:3] # 1) core MSs
MS_addn = MSs_all[4:length(MSs_all)] # additionally typed MSs

# Format dataframe
MS_typd = MS_pooled_summary # Rename before relaplacing allele information with binary
MS_typd[,MSs_all][!is.na(MS_typd[,MSs_all])] = 1 # Replace allele information with binary

# Extract numbers of markers typed 
MS_core_count = length(MS_core) - rowSums(is.na(MS_typd[,MS_core])) # Extract number of markers typed per episode
MS_typd_count = length(MSs_all) - rowSums(is.na(MS_typd[,MSs_all])) # Extract number of markers typed per episode
MS_addn_count = length(MS_addn) - rowSums(is.na(MS_typd[,MS_addn])) # Extract the number of additional markers typed per episode
MS_addn_count_recurrent = length(MS_addn) - rowSums(is.na(MS_typd[MS_typd$Episode > 1,MS_addn])) # Extract the number of additional markers typed per recurrent episode

names(MS_typd_count) = names(MS_addn_count) = names(MS_core_count) = MS_typd$Episode_Identifier # Name by episode

# Logical indeces
BPD_ind = grepl('BPD_', MS_typd$ID) # BPD individuals
VHX_ind = grepl('VHX_', MS_typd$ID) # VHX individuals
```

Summaries across all samples selected

```{r}
#==========================================================================
# Summaries of core and additional (non-core) typed
# Zero samples failed at 6 of 6 non-core markers (email from Mallika June 12 2019)
# As such, zero non-core marker data means that zero additional were attempted 
#==========================================================================
writeLines(sprintf('\nNumbers of %s samples partioned by number of markers successfully typed:', sum(table(MS_typd_count))))
table(MS_typd_count)

writeLines(sprintf('\nNumbers of %s samples partioned by number of core markers successfully typed:', sum(table(MS_core_count))))
table(MS_core_count) 

writeLines(sprintf('\nNumbers of %s samples partioned by number of non-core markers successfully typed:', sum(table(MS_addn_count))))
table(MS_addn_count) 

writeLines(sprintf('\nNumbers of %s recurrent samples partioned by number of non-core markers successfully typed:', sum(table(MS_addn_count_recurrent) )))
table(MS_addn_count_recurrent) 

#=================================================
# Episodes with missing core: share with Mallika
Episodes_missing_core = names(MS_core_count)[(which(MS_core_count < 3))] # Names 
Data_missing_core = MS_typd[MS_typd$Episode_Identifier %in% Episodes_missing_core, ] # All data 
MSData_missing_core = Data_missing_core[, c(MS_core, MS_addn)] # MS Data
rownames(MSData_missing_core) = Data_missing_core$Episode_Identifier # name rows
#write.csv(x = MSData_missing_core, file = '~/Dropbox/Genotyping/MSData_missing_core.csv', row.names = T) # Print
#=================================================

writeLines(sprintf('\nNumber of enrolment samples successfully genotyped at additional (non-core) markers: %s of %s (%s percent, %s VHX, %s BPD)',
                   sum(MS_typd$Episode[MS_addn_count > 0] == 1),
                   sum(MS_typd$Episode == 1), 
                   round(100*sum(MS_typd$Episode[MS_addn_count > 0] == 1)/sum(MS_typd$Episode == 1)), 
                   sum(MS_typd$Episode[VHX_ind][MS_addn_count[VHX_ind] > 0] == 1), # VHX
                   sum(MS_typd$Episode[BPD_ind][MS_addn_count[BPD_ind] > 0] == 1))) # BPD

writeLines(sprintf('Number of recurrent samples successfully genotyped at additional (non-core) markers: %s of %s (%s percent, %s VHX, %s BPD)',
                   sum(MS_typd$Episode[MS_addn_count > 0] != 1),
                   sum(MS_typd$Episode != 1), 
                   round(100*sum(MS_typd$Episode[MS_addn_count > 0] != 1)/sum(MS_typd$Episode != 1)), 
                   sum(MS_typd$Episode[VHX_ind][MS_addn_count[VHX_ind] > 0] != 1), # VHX
                   sum(MS_typd$Episode[BPD_ind][MS_addn_count[BPD_ind] > 0] != 1))) # BPD

writeLines(sprintf('Of those successfully genotyped at additional (non-core) markers, number genotyped at all six: %s of %s (%s percent, %s VHX, %s BPD)',
                   sum(MS_addn_count[MS_addn_count > 0] == 6), 
                   sum(MS_addn_count > 0),
                   round(100*sum(MS_addn_count[MS_addn_count > 0] == 6)/sum(MS_addn_count > 0)), 
                   sum(MS_addn_count[VHX_ind][MS_addn_count[VHX_ind] > 0] == 6), # VHX
                   sum(MS_addn_count[BPD_ind][MS_addn_count[BPD_ind] > 0] == 6))) # BPD
```

# Now we remove MS data for indiviuduals who miss paired enrolment and recurrent data in preparation for recurrent state inference

```{r}
# First we remove MS data for which there are either no recurrent data or no enrolment data 
IDs_Enrolment_n_Recurrent_typed = sapply(unique(MS_pooled_summary$ID), function(id){
  inds = MS_pooled_summary$ID == id
  episodes = MS_pooled_summary$Episode[inds] 
  if(!1 %in% episodes){print(sprintf('enrolment missing for %s',id))}
  if(!length(episodes) > 1){print(sprintf('recurrent missing for %s',id))}
  if(length(episodes) > 1 & 1 %in% episodes){id}else{NA}  # one or more recurrent and contains and enrolment episode 
  })

# Check that 'BPD_564' had only a single recurrence thus unanalzable: yes
MS_pooled$Episode[MS_pooled$ID == 'BPD_564'] 

writeLines(sprintf('\nIndividuals removed due to missing enrolment or no recurrent data: \n %s', 
paste(IDs_Enrolment_n_Recurrent_typed[is.na(IDs_Enrolment_n_Recurrent_typed)], collapse = ' ')))

#-----------------------------------------------------
# Redefine dataframes XXX Consider re-nameing so code is more robust
#-----------------------------------------------------
MS_pooled = filter(MS_pooled, ID %in% IDs_Enrolment_n_Recurrent_typed[!is.na(IDs_Enrolment_n_Recurrent_typed)])
MS_pooled_summary = MS_pooled[!duplicated(MS_pooled$Episode_Identifier),]  # recreate pooled summary dataset
MS_typd = MS_pooled_summary # Rename before relaplacing allele information with binary
MS_typd[,MSs_all][!is.na(MS_typd[,MSs_all])] = 1 # Replace allele information with binary

recur_ind = MS_pooled$Episode > 1
writeLines('\nNumber of individuals with at least one paired recurrence typed by treatment:')
table(MS_pooled$trial_arm_partner[recur_ind][!duplicated(MS_pooled$ID[recur_ind])])[treatment_order]
writeLines('\nPercent of Nr individuals with at least one paired recurrence typed by treatment:') 
round(100*table(MS_pooled$trial_arm_partner[recur_ind][!duplicated(MS_pooled$ID[recur_ind])])[names(Nr)]/Nr)[treatment_order]

recur_ind = MS_pooled_summary$Episode > 1
writeLines('\nNumber of paired recurrences typed by treatment:')
table(MS_pooled_summary$trial_arm_partner[recur_ind])[treatment_order]
writeLines('\nPercent of paired recurrences typed by treatment:') 
round(100*table(MS_pooled_summary$trial_arm_partner[recur_ind])[names(R)]/R)[treatment_order] 

writeLines(sprintf('\nNumber of individuals with one or more paired recurrence: %s',
                   length(unique(MS_pooled$ID))))
writeLines(sprintf('Number of episodes in individuals with one or more paired recurrence: %s',
                   length(unique(MS_pooled$Episode_Identifier))))
writeLines(sprintf('Number of paired recurrences: %s',
                   length(unique(MS_pooled$Episode_Identifier[MS_pooled$Episode>1]))))

# To add to Table 3
# Re-extract number of add. markers typed per episode
MS_addn_count_recurrent = length(MS_addn) - rowSums(is.na(MS_typd[MS_typd$Episode > 1,MS_addn])) 
names(MS_addn_count_recurrent) = MS_typd[MS_typd$Episode > 1,'Episode_Identifier']
writeLines(sprintf('\nNumbers of %s paired recurrent samples partioned by number of non-core markers successfully typed:', sum(table(MS_addn_count_recurrent))))
table(MS_addn_count_recurrent) 
```


# Computing the probability of relatedness across infections

The approach is Bayesian and consists of the following:

* A prior probability vector for the recurrence state from the time-to-event model
* An allele frequency estimate from the posterior distribution of allele frequencies
* A likelihood based on the genetic data of being a *relapse*, a *recrudescence*, or a *reinfection* given the observed microsatellite data.

The following iterates through each individual and computes the probability of relatedness states.

## Load the time-to-event priors

```{r}
inds = grepl('mean_theta', colnames(Mod2_ThetaEstimates)) # Extract mean
p = data.frame(Episode_Identifier = Mod2_ThetaEstimates$Episode_Identifier, 
               Mod2_ThetaEstimates[,inds], stringsAsFactors = F) # Reformat
colnames(p) = gsub(pattern = 'Recrudescence_mean_theta',replacement = 'C',x = colnames(p))
colnames(p) = gsub(pattern = 'Relapse_mean_theta',replacement = 'L',x = colnames(p))
colnames(p) = gsub(pattern = 'ReInfection_mean_theta',replacement = 'I',x = colnames(p))

# Get prior estimates for only those with genetic data
genetic_AND_time_data_eps = intersect(p$Episode_Identifier, MS_pooled$Episode_Identifier)
p = p[p$Episode_Identifier %in% genetic_AND_time_data_eps,]

# Extract posterior estimates only if running full posterior simple or inflated
if(RUN_MODELS_FULL_POSTERIOR | RUN_MODELS_FULL_POSTERIOR_INFLATED){
  Post_samples_matrix = Post_samples_matrix[Post_samples_matrix$Episode_Identifier %in% genetic_AND_time_data_eps,]
}
```


## Computation

```{r}
# Remove upper complexity ids if EXCLUDE_COMPLEX = T
# This substantially speeds up the analysis
if(EXCLUDE_COMPLEX){
  load('../RData/UpperComplexityIDs.RData') # IDs to avoid
  ep_ids_excluded = unique(MS_pooled$Episode_Identifier[MS_pooled$ID %in% UpperComplexityIDs])
  MS_pooled = MS_pooled[!MS_pooled$ID %in% UpperComplexityIDs,]
  writeLines(sprintf('This is excluding data from %s individuals, totalling %s vivax episodes',
                     length(UpperComplexityIDs), length(ep_ids_excluded)))
}
```


### Full posterior computation: non-complex cases
#### Using the time-to-event prior

```{r, include=FALSE}
f_name = paste(f_name_prefix, 'Full_Posterior_Model_samples.RData', sep='_')
if(RUN_MODELS_FULL_POSTERIOR){
  
  #===============================================
  # Run full Bayesian with sampling at random from time prior 
  # (treats time posterior as discrete uniform prior)
  # takes about 4 hours on 6 cores
  # The outer loop is not parallelised - suboptimal coding
  #===============================================
  
  # Run using mean allele frequencies
  thetas_9MS = post_prob_CLI(MSdata = MS_pooled, 
                             Fs = Fs_Combined, 
                             p = p, 
                             cores = Ncores, verbose = F) 
  thetas_9MS$Episode_Identifier = rownames(thetas_9MS)
  
  Ksamples = min(length(grep('C',colnames(Post_samples_matrix))), Ksamples_min)
  tic()
  Thetas_full_post = foreach(ss = 1:Ksamples, .combine = cbind) %do% {
    
    # draw a random distribution over the allele frequencies from posterior
    Fs_random = lapply(Alpha_Posteriors, rdirichlet, n=1)
    
    # This step is important since we use the haplotype labels to extract allele frequencies in Log_Pr_yn_Gab
    for(i in 1:length(Fs_random)){names(Fs_random[[i]]) = 1:length(Fs_random[[i]])}
    
    # take the ss sample from the time prior
    indices = c(grep('C',colnames(Post_samples_matrix))[ss],
                grep('L',colnames(Post_samples_matrix))[ss],
                grep('I',colnames(Post_samples_matrix))[ss],
                grep('Episode_Identifier',colnames(Post_samples_matrix)))
    p = Post_samples_matrix[,indices]
    
    # run the model
    thetas_9MS = post_prob_CLI(MSdata = MS_pooled, Fs = Fs_random, p = p, 
                               cores = Ncores, verbose = F) 
    thetas_9MS$Episode_Identifier = rownames(thetas_9MS)
    thetas_9MS
  }
  
  # Pull out the credible intervals
  CI_C = apply(Thetas_full_post[,'C' == colnames(Thetas_full_post)],1, 
               quantile, probs = c(lowerCI, 0.5, upperCI), na.rm=T)
  CI_L = apply(Thetas_full_post[,'L' == colnames(Thetas_full_post)],1, 
               quantile, probs = c(lowerCI, 0.5, upperCI), na.rm=T)
  CI_R = apply(Thetas_full_post[,'I' == colnames(Thetas_full_post)],1, 
               quantile, probs = c(lowerCI, 0.5, upperCI), na.rm=T)
  CIs = t(rbind(CI_C, CI_L, CI_R)) 
  colnames(CIs) = paste(rep(c('C', 'L', 'I'), each = 3), colnames(CIs), sep = '')
  thetas_9MS = cbind(thetas_9MS, CIs)
  
  
  #save(thetas_9MS, file = f_name)
  toc()
} else {
  load(file = f_name)
}
```

For genetic only efficacy estimate, run time agnostic (i.e. genetic only)

```{r, include=FALSE}

f_name = paste(f_name_prefix, 'Full_Posterior_Model_samples_Tagnostic.RData', sep='_')

if(RUN_MODELS_FULL_POSTERIOR_TAGNOSTIC){
  
  #===============================================
  # Run full Bayesian with sampling at random from 
  # microsatellite allele frequency posterior distribution
  #===============================================
  
  # Use the same number as used in the time informed analysis
  Ksamples = min(length(grep('C',colnames(Post_samples_matrix))), Ksamples_min)
  tic()
  
  Thetas_Full_Tagnostic = foreach(ss = 1:Ksamples, .combine = cbind) %do% {
    
    # Draw a sample of allele frequencies
    Fs_random = lapply(Alpha_Posteriors, rdirichlet, n=1)
    
    # Name alleles (important since we use the haplotype labels to extract allele frequencies in Log_Pr_yn_Gab)
    for(i in 1:length(Fs_random)){names(Fs_random[[i]]) = 1:length(Fs_random[[i]])}
    
    # Run the model 
    thetas = post_prob_CLI(MSdata = MS_pooled, 
                           Fs = Fs_random, 
                           cores = Ncores, 
                           verbose = F) 
    thetas # return for %do%
  }
  
  # Run with non random fs 
  thetas_9MS_Tagnostic = post_prob_CLI(MSdata = MS_pooled, 
                                       Fs = Fs_Combined, 
                                       cores = Ncores, verbose = F) 
  thetas_9MS_Tagnostic$Episode_Identifier = rownames(thetas_9MS_Tagnostic)
  
  # Pull out the credible intervals
  CI_C = apply(Thetas_Full_Tagnostic[,grep('C', colnames(Thetas_Full_Tagnostic))],1, 
               quantile, probs = c(lowerCI, 0.5, upperCI), na.rm=T)
  CI_L = apply(Thetas_Full_Tagnostic[,grep('L', colnames(Thetas_Full_Tagnostic))],1, 
               quantile, probs = c(lowerCI, 0.5, upperCI), na.rm=T)
  CI_R = apply(Thetas_Full_Tagnostic[,grep('I', colnames(Thetas_Full_Tagnostic))],1, 
               quantile, probs = c(lowerCI, 0.5, upperCI), na.rm=T)
  CIs = t(rbind(CI_C, CI_L, CI_R)) 
  colnames(CIs) = paste(rep(c('C', 'L', 'I'), each = 3), colnames(CIs), sep = '')
  
  # Combine and save
  thetas_9MS_Tagnostic = cbind(thetas_9MS_Tagnostic, CIs)
  save(thetas_9MS_Tagnostic, file = f_name)
  toc()
} else {
  load(file = f_name)
}
```

# Plot results (thus far we have results for individuals with one or two recurrences only)

```{r}
# Output of time-to-event model (sorted by episode number s.t. columns correspond)
Time_Estimates_1 = filter(Mod2_ThetaEstimates, Episode_Identifier %in% thetas_9MS$Episode_Identifier)
Time_Estimates_1 = arrange(Time_Estimates_1, Episode_Identifier)

# Outputs of genetic model with time prior 
# sorted by episode number s.t. columns correspond and drug added
thetas_9MS = arrange(thetas_9MS, Episode_Identifier)
thetas_9MS$drug = Time_Estimates_1$arm_num # Add drug

# Outputs of genetic model without time prior 
# sorted by episode number s.t. columns correspond and drug added
thetas_9MS_Tagnostic = arrange(thetas_9MS_Tagnostic, Episode_Identifier)
thetas_9MS_Tagnostic$drug = Time_Estimates_1$arm_num # Add drug
```

## Going from time-to-event prior to posterior

Plotted by radical cure versus no radical cure, as that is the most informative distinction here.

```{r Supplementary_TimeEffect_onPosterior, fig.width=7, fig.height=7, echo=FALSE}
if(CREATE_PLOTS){
  par(mfrow=c(2,2),las=1, bty='n',family='serif')
  
  # Time agnostic versus full posterior 
  plot(x = thetas_9MS_Tagnostic$L, 
       y = thetas_9MS$L, 
       log = 'xy', las = 2, 
       xlab = 'Genetic given time-agnostic prior', 
       ylab = 'Genetic given time-to-event based prior',
       panel.first = grid(),
       col = drug_cols2[thetas_9MS$drug], 
       main = 'Probability of relapse',pch=20)
  abline(a = 0, b = 1)
  
  polygon(x = c(range(thetas_9MS_Tagnostic$L, na.rm = T),
                rev(range(thetas_9MS_Tagnostic$L, na.rm = T))),
          y = c(Epsilon_lower,
                Epsilon_lower,
                Epsilon_upper,
                Epsilon_upper),
          col = transparent_blue_band, border = NA)
  
  polygon(y = c(range(thetas_9MS$L, na.rm = T),
                rev(range(thetas_9MS$L, na.rm = T))),
          x = c(Epsilon_lower,
                Epsilon_lower,
                Epsilon_upper,
                Epsilon_upper),
          col = transparent_blue_band, border = NA)
  
  plot(x = thetas_9MS_Tagnostic$I, 
       y = thetas_9MS$I, 
       xlab = 'Genetic given time-agnostic prior', 
       ylab = 'Genetic given time-to-event based prior',
       log = 'xy', las = 2, 
       panel.first = grid(),
       col = drug_cols2[thetas_9MS$drug], 
       main = 'Probability of reinfection',pch=20)
  abline(a = 0, b = 1)
  legend('topleft', legend = c('No PMQ', 'PMQ+'), inset = 0.05, 
         col = drug_cols2[2:3], pch = 20, bty = 'o', bg = 'white')
  
  # Prior versus full posterior
  plot(x = Time_Estimates_1$Relapse_mean_theta,
       y = thetas_9MS$L,
       xlab = 'Time-to-event (genetic time-to-event based prior)', 
       ylab = 'Genetic given time-to-event based prior',
       log = 'xy', las = 2, 
       panel.first = grid(),
       col= drug_cols2[thetas_9MS$drug],
       main = 'Probability of relapse',pch=20)
  abline(a = 0, b = 1)
  
  polygon(x = c(range(Time_Estimates_1$Relapse_mean_theta, na.rm = T),
                rev(range(Time_Estimates_1$Relapse_mean_theta, na.rm = T))),
          y = c(Epsilon_lower,
                Epsilon_lower,
                Epsilon_upper,
                Epsilon_upper),
          col = transparent_blue_band, border = NA)
  
  polygon(y = c(range(thetas_9MS$L, na.rm = T),
                rev(range(thetas_9MS$L, na.rm = T))),
          x = c(Epsilon_lower,
                Epsilon_lower,
                Epsilon_upper,
                Epsilon_upper),
          col = transparent_blue_band, border = NA)
  
  
  plot(x = Time_Estimates_1$ReInfection_mean_theta,
       y = thetas_9MS$I,
       log = 'xy', las = 2, 
       xlab = 'Time-to-event (genetic time-to-event based prior)', 
       ylab = 'Genetic given time-to-event based prior',
       panel.first = grid(), 
       col= drug_cols2[thetas_9MS$drug], 
       main = 'Probability of reinfection', pch=20)
  abline(a = 0, b = 1)
}
# Summary of changes 
ind = thetas_9MS$drug == "CHQ" | thetas_9MS$drug == "AS"
no_pmq = sum(ind)
pmq = sum(!ind)

# No PMQ
writeLines(sprintf('Based on time-to-event alone, %s of %s No PMQ classified as relapse', 
                   sum(Time_Estimates_1$Relapse_mean_theta[ind] >= Epsilon_upper, na.rm = T), no_pmq))
writeLines(sprintf('Based on genetic alone, %s of %s No PMQ classified as relapse', 
                   sum(thetas_9MS_Tagnostic$L[ind] >= Epsilon_upper, na.rm = T), no_pmq))
writeLines(sprintf('Based on all available data, %s of %s No PMQ classified as relapse', 
                   sum(thetas_9MS$L[ind] >= Epsilon_upper, na.rm = T), no_pmq))

# PMQ+
writeLines(sprintf('Based on time-to-event alone, %s of %s PMQ+ classified as relapse', 
                   sum(Time_Estimates_1$Relapse_mean_theta[!ind] >= Epsilon_upper, na.rm = T), pmq))
writeLines(sprintf('Based on genetic alone, %s of %s PMQ+ classified as relapse', 
                   sum(thetas_9MS_Tagnostic$L[!ind] >= Epsilon_upper, na.rm = T), pmq))
writeLines(sprintf('Based on all available data, %s of %s PMQ+ classified as relapse', 
                   sum(thetas_9MS$L[!ind] >= Epsilon_upper, na.rm = T), pmq))
```

Probability of states, ordered from most to least likely:

XXX Need to sort plotting bug - apprently appears only after first run

```{r, fig.height=6, echo=FALSE}
if(CREATE_PLOTS){
  par(mfrow=c(3,2),las=1, bty='n',family = 'serif')
  for(state in states){
    
    # Get ranks 
    ordered = sort.int(thetas_9MS[,state], decreasing = TRUE, index.return = TRUE)
    
    # Plot genetic with time-to-event
    plot(ordered$x, panel.first = grid(), pch=20, 
         col = drug_cols2[thetas_9MS$drug[ordered$ix]],
         xlab = 'Rank', 
         ylab = sprintf('Probability of %s state', state),
         main = 'Genetic model given time-to-event prior')
    legend('topright',col = drug_cols2[2:3], bty = 'n', legend = c('No PMQ','PMQ+'),pch=20)
    
    CI_cols = which(colnames(thetas_9MS)==paste(state,'2.5%',sep='') | colnames(thetas_9MS)==paste(state,'97.5%',sep=''))
    for(i in 1:length(ordered$ix)){
        segments(x0 = i, y0 = thetas_9MS[ordered$ix[i],CI_cols[2]], 
                 x1 = i, y1 = thetas_9MS[ordered$ix[i],CI_cols[1]],
                 col = drug_cols2[thetas_9MS$drug[ordered$ix[i]]])}
    
    # Plot genetic with time-agnostic prior
    ordered = sort.int(thetas_9MS_Tagnostic[,state], decreasing = TRUE, index.return = TRUE)
    
    plot(ordered$x, 
         panel.first = grid(), 
         pch=20, cex=.8,
         col = drug_cols2[thetas_9MS$drug[ordered$ix]],
         xlab = 'Rank', 
         ylab = sprintf('Probability of %s state',state),
         main = 'Genetic model given time-agnostic prior')
    legend('topright',col = drug_cols2[2:3], bty = 'n', legend = c('No PMQ','PMQ+'),pch=20)
    
    CI_cols = which(colnames(thetas_9MS)==paste(state,'2.5%',sep='') | colnames(thetas_9MS)==paste(state,'97.5%',sep=''))
    for(i in 1:length(ordered$ix)){
        segments(x0 = i, y0 = thetas_9MS[ordered$ix[i],CI_cols[2]], 
                 x1 = i, y1 = thetas_9MS[ordered$ix[i],CI_cols[1]],
                 col = drug_cols2[thetas_9MS$drug[ordered$ix[i]]])}
  }
}
```



#### Extra computations for VHX: complex episodes

We remove the IDs that can be straightforwardly calculated:

```{r}
ind_calculated = which(MS_pooled_summary$Episode_Identifier %in% thetas_9MS$Episode_Identifier)
IDs_calculated = unique(MS_pooled_summary$ID[ind_calculated])
IDs_remaining = unique(MS_pooled_summary$ID[! MS_pooled_summary$ID %in% IDs_calculated])
writeLines(sprintf('individuals with more than two recurrences: %s',length(IDs_remaining)))
```

We blow up the pooled analysis into all pairs within individuals:

```{r, include=FALSE}
MS_inflate = reformat_MSdata(filter(MS_pooled, ID %in% IDs_remaining), MSs = MSs_all)
MS_inflated = Inflate_into_pairs(MS_data = MS_inflate)
writeLines(sprintf('Number of pairwise probabilities of recurrence states between episodes: %s',length(unique(MS_inflated$ID))))
```


```{r, include=FALSE}
f_name = paste(f_name_prefix, 'Full_Posterior_Inflated.RData', sep='_')

if(RUN_MODELS_FULL_POSTERIOR_INFLATED){  
  
  all_rec_eps_ind = !duplicated(MS_inflated$Episode_Identifier) &
    MS_inflated$Episode==2
  all_rec_eps = MS_inflated$Episode_Identifier[all_rec_eps_ind]
  P_matrix = data.frame(array(dim = c(length(all_rec_eps),4)))
  colnames(P_matrix) = c('Episode_Identifier','C','I','L')
  P_matrix$Episode_Identifier = all_rec_eps
  Ksamples = min(Ksamples_min, length(grep('C',colnames(Post_samples_matrix))))
  
  K_results = sum(!duplicated(MS_inflated$Episode_Identifier[MS_inflated$Episode>1]))
  
  tic()
  # Outer loop is not parallelised
  Res_total=foreach(ss = 1:Ksamples, .combine = cbind) %do% {
    
    # draw a random distribution over the allele frequencies from posterior
    Fs_random = lapply(Alpha_Posteriors, rdirichlet, n=1)
    
    # Name allele: important since we use the haplotype labels to 
    # extract allele frequencies in Log_Pr_yn_Gab
    for(i in 1:length(Fs_random)) {
      names(Fs_random[[i]]) = 1:length(Fs_random[[i]])
    }
    
    # take the ss sample from the time prior
    rec_states = c('C','L','I')
    indices = c(grep(rec_states[1],colnames(Post_samples_matrix))[ss],
                grep(rec_states[2],colnames(Post_samples_matrix))[ss],
                grep(rec_states[3],colnames(Post_samples_matrix))[ss])
    
    for(ep in all_rec_eps){
      i = which(P_matrix$Episode_Identifier==ep)
      j = which(MS_inflated$Episode_Identifier==ep)[1]
      k = which(Post_samples_matrix$Episode_Identifier == 
                  paste(MS_inflated$ID_True[j],
                        as.integer(MS_inflated$Second_EpNumber[j]),
                        sep='_'))
      P_matrix[i,rec_states] = Post_samples_matrix[k,indices]
    }
    writeLines(sprintf('\n ****** on iteration %s ****** \n',ss))
    # This is about 6 minutes per run
    Res = post_prob_CLI(MSdata = MS_inflated, 
                        Fs = Fs_random, 
                        p = P_matrix,
                        UpperComplexity = 10^6, 
                        verbose = F,
                        cores = Ncores)
    Res
  }
  toc()
  # Summarise the results
  
  # Pull out the credible intervals
  CI_C = apply(Res_total[,grep('C', colnames(Res_total))],1, 
               quantile, probs = c(lowerCI, 0.5, upperCI), na.rm=T)
  CI_L = apply(Res_total[,grep('L', colnames(Res_total))],1, 
               quantile, probs = c(lowerCI, 0.5, upperCI), na.rm=T)
  CI_R = apply(Res_total[,grep('I', colnames(Res_total))],1, 
               quantile, probs = c(lowerCI, 0.5, upperCI), na.rm=T)
  CIs = t(rbind(CI_C, CI_L, CI_R)) 
  colnames(CIs) = paste(rep(c('C', 'L', 'I'), each = 3), colnames(CIs), sep = '')
  
  
  Results_Inflated= as.data.frame(CIs)
  save(Results_Inflated, file = f_name)
} else {
  load(f_name)
}
```


Construct adjacency graphs and compute probabilities of relapse and reinfection.

```{r}
MS_pooled_summary$L_or_C_state = MS_pooled_summary$TotalEpisodes = NA
MS_pooled_summary$L_lower = MS_pooled_summary$L_upper = MS_pooled_summary$L_median = NA
MS_pooled_summary$C_lower = MS_pooled_summary$C_upper = MS_pooled_summary$C_median = NA
MS_pooled_summary$I_lower = MS_pooled_summary$I_upper = MS_pooled_summary$I_median = NA
# Arrange by complexity
# Get single rows per episode (throw away the extra MOI information)
MS_inflated_summary = MS_inflated[!duplicated(MS_inflated$Episode_Identifier) & 
                                    MS_inflated$Episode==2,]
Results_Inflated$Episode_Identifier = as.character(rownames(Results_Inflated))

for(i in 1:nrow(MS_inflated_summary)){
  if(!length(which(MS_inflated_summary$Episode_Identifier[i] == 
                   Results_Inflated$Episode_Identifier))>0){
    MS_inflated_summary = MS_inflated_summary[-i,]
    print('removing')
  }
}

Results_Inflated$ID_True = NA
Results_Inflated$First_EpNumber = NA
Results_Inflated$Second_EpNumber = NA
# The ordering has changed so need to be careful about naming
for(i in 1:nrow(Results_Inflated)){
  ind_MS_inflated = which(MS_inflated_summary$Episode_Identifier==Results_Inflated$Episode_Identifier[i])
  Results_Inflated$ID_True[i] = 
    MS_inflated_summary$ID_True[ind_MS_inflated]
  Results_Inflated$First_EpNumber[i] =
    MS_inflated_summary$First_EpNumber[ind_MS_inflated]
  Results_Inflated$Second_EpNumber[i] =
    MS_inflated_summary$Second_EpNumber[ind_MS_inflated]
}



# Iterate through the ones we can calculate in one go
episodes_full_model = unique(thetas_9MS$Episode_Identifier)
for(ep in episodes_full_model){
  ind1 = MS_pooled_summary$Episode_Identifier==ep
  ind2 = thetas_9MS$Episode_Identifier==ep
  
  ## Summaries for relapse
  L_cols = grep('L',colnames(thetas_9MS))
  MS_pooled_summary$L_upper[ind1] = thetas_9MS[ind2, paste('L','97.5%',sep='')]
  MS_pooled_summary$L_lower[ind1] = thetas_9MS[ind2, paste('L','2.5%',sep='')]
  MS_pooled_summary$L_median[ind1] = thetas_9MS[ind2, paste('L','50%',sep='')]
  
  ## Summaries for recrudescence
  C_cols = grep('C',colnames(thetas_9MS))
  MS_pooled_summary$C_upper[ind1] = thetas_9MS[ind2, paste('C','97.5%',sep='')]
  MS_pooled_summary$C_lower[ind1] = thetas_9MS[ind2, paste('C','2.5%',sep='')]
  MS_pooled_summary$C_median[ind1] = thetas_9MS[ind2, paste('C','50%',sep='')]
  
  ## Summaries for reinfection
  I_cols = grep('I',colnames(thetas_9MS))
  MS_pooled_summary$I_upper[ind1] = thetas_9MS[ind2, paste('I','97.5%',sep='')]
  MS_pooled_summary$I_lower[ind1] = thetas_9MS[ind2, paste('I','2.5%',sep='')]
  MS_pooled_summary$I_median[ind1] = thetas_9MS[ind2, paste('I','50%',sep='')]
  
  # Just going to classify on relapse versus reinfection
  if(!is.na(MS_pooled_summary$L_upper[ind1])){
    if(MS_pooled_summary$L_upper[ind1]+MS_pooled_summary$C_upper[ind1] < Epsilon_lower){
      MS_pooled_summary$L_or_C_state[ind1] = 'I'
    } else if(MS_pooled_summary$L_lower[ind1]+MS_pooled_summary$C_lower[ind1] > Epsilon_upper){
      MS_pooled_summary$L_or_C_state[ind1] = 'L'
    } else {
      MS_pooled_summary$L_or_C_state[ind1] = 'Uncertain'
    }
  } else {
    MS_pooled_summary$L_or_C_state[ind1] = NA
  }
}
```


```{r}
####******** Complex cases *******####################
# Now iterate through the complex ones
for(i in 1:length(IDs_remaining)){
  id = IDs_remaining[i]
  Doubles_Thetas = filter(Results_Inflated, ID_True==id)
  
  for(ep in unique(Doubles_Thetas$Second_EpNumber)){
    # indices on the MS_pooled_summary
    ind1 = which(MS_pooled_summary$ID==id & MS_pooled_summary$Episode==ep)
    # indices on Doubles thetas: looking for relapse evidence
    ind2 = which(Doubles_Thetas$Second_EpNumber == ep)
    # index for recrudescence evidence
    ind3 = which(Doubles_Thetas$Second_EpNumber == ep &
                   Doubles_Thetas$First_EpNumber == (ep-1))
    
    best_match_relapse = which.max(Doubles_Thetas[ind2, paste('L','50%',sep='')])
    if(length(best_match_relapse)>0){
      # Relapse probability
      MS_pooled_summary$L_lower[ind1] = Doubles_Thetas[ind2[best_match_relapse], paste('L','2.5%',sep='')]
      MS_pooled_summary$L_upper[ind1] = Doubles_Thetas[ind2[best_match_relapse], paste('L','97.5%',sep='')]
      MS_pooled_summary$L_median[ind1] = Doubles_Thetas[ind2[best_match_relapse], paste('L','50%',sep='')]
      
      # Reinfection probability
      MS_pooled_summary$I_lower[ind1] = Doubles_Thetas[ind2[best_match_relapse], paste('I','2.5%',sep='')]
      MS_pooled_summary$I_upper[ind1] = Doubles_Thetas[ind2[best_match_relapse], paste('I','97.5%',sep='')]
      MS_pooled_summary$I_median[ind1] = Doubles_Thetas[ind2[best_match_relapse], paste('I','50%',sep='')]
      
      # Recrudescence probability
      if(length(ind3)>0){ 
        # we can compute using previous episode
        MS_pooled_summary$C_lower[ind1] = Doubles_Thetas[ind3, paste('C','2.5%',sep='')]
        MS_pooled_summary$C_upper[ind1] = Doubles_Thetas[ind3, paste('C','97.5%',sep='')]
        MS_pooled_summary$C_median[ind1] = Doubles_Thetas[ind3, paste('C','50%',sep='')]
      }  
      if(is.na(MS_pooled_summary$C_median[ind1])){
        MS_pooled_summary$C_lower[ind1] =
          1-MS_pooled_summary$L_lower[ind1]+MS_pooled_summary$I_lower[ind1]
        MS_pooled_summary$C_upper[ind1] = 
          1-MS_pooled_summary$L_upper[ind1]+MS_pooled_summary$I_upper[ind1]
        MS_pooled_summary$C_median[ind1] = 
          1-MS_pooled_summary$L_median[ind1]+MS_pooled_summary$I_median[ind1]
      }
      
    }
    if(!is.na(MS_pooled_summary$C_median[ind1])){
      if(MS_pooled_summary$L_upper[ind1] < MS_pooled_summary$L_lower[ind1]){
        writeLines(sprintf('Problem with ID %s',id))
        stop()
      }
      if(MS_pooled_summary$L_upper[ind1]+MS_pooled_summary$C_upper[ind1] < Epsilon_lower){
        MS_pooled_summary$L_or_C_state[ind1] = 'I'
      } else if(MS_pooled_summary$L_lower[ind1]+MS_pooled_summary$C_lower[ind1] > Epsilon_upper){
        MS_pooled_summary$L_or_C_state[ind1] = 'L'
      } else {
        MS_pooled_summary$L_or_C_state[ind1] = 'Uncertain'
      }
    }
  }
}

MS_pooled_summary$Drug = MS_pooled_summary$FU = NA
for(id in MS_pooled_summary$ID){
  ind = MS_pooled_summary$ID==id
  MS_pooled_summary$TotalEpisodes[ind] = max(MS_pooled_summary$Episode[ind])
  MS_pooled_summary$Drug[ind] = as.numeric(
    Combined_Time_Data$arm_num[Combined_Time_Data$patientid==id][1] == 'CHQ/PMQ') + 2
  MS_pooled_summary$FU[ind] = Combined_Time_Data$FU_time[Combined_Time_Data$patientid==id][1]
}
MS_pooled_summary$Plotting_pch_Values = 
  as.numeric(mapvalues(MS_pooled_summary$L_or_C_state, from = c('L','Uncertain','I'), to = c(17,15,25)))
MS_pooled_summary$Plotting_col_Values = 
  as.numeric(mapvalues(MS_pooled_summary$L_or_C_state, from = c('L','Uncertain','I'), to = 1:3))
```


```{r}
# How many too complex to generate estimate for? 
ind_recur = MS_pooled_summary$Episode > 1 # Filter out enrollment
ind_complex_recur = is.na(MS_pooled_summary$L_median[ind_recur])
no_complex_recur = sum(ind_complex_recur) # Recurrences with NAs
recur_removed = MS_pooled_summary$Episode_Identifier[ind_recur][ind_complex_recur]

# How many of the complex infections result in the loss of an individual
N_episodes_typed = table(MS_pooled_summary$ID)
indiv_removed = names(which(N_episodes_typed[MS_pooled_summary$ID[ind_recur][ind_complex_recur]] <= 2)) 
no_indiv_removed = length(indiv_removed)

# Final number of people with recurrences analysed total and by trial
indiv_recur_analysed = length(unique(MS_pooled_summary$ID[ind_recur][!ind_complex_recur])) 
BPD_indiv_recur_analysed = sum(grepl('BPD', unique(MS_pooled_summary$ID[ind_recur][!ind_complex_recur])))
VHX_indiv_recur_analysed = sum(grepl('VHX', unique(MS_pooled_summary$ID[ind_recur][!ind_complex_recur]))) 

writeLines(sprintf('\nOf %s recurrences analysed, %s were too complex to estimate recurrence state probabilities: \n%s, \nresulting in probability estimates for a total of %s recurrences from %s individuals (%s BPD and %s VHX)',
                   sum(ind_recur), no_complex_recur,  
                   paste(recur_removed, collapse = ' '), 
                   sum(!ind_complex_recur), 
                   indiv_recur_analysed, BPD_indiv_recur_analysed, VHX_indiv_recur_analysed))

# Which drug arms do the unanalysed recurrences/individuals come from? 
X0 = filter(MS_pooled_summary[MS_pooled_summary$Episode == 1,], ID %in% indiv_removed)
X1 = X0$trial_arm_partner; names(X1) = X0$ID
writeLines('\nIndividuals ommited due to computation complexity: ')
X1

X0 = filter(MS_pooled_summary, Episode_Identifier %in% recur_removed)
X1 = X0$trial_arm_partner; names(X1) = X0$Episode_Identifier
writeLines('\nRecurrences ommited due to computation complexity:')
X1

recur_ind = MS_pooled_summary$Episode > 1
X0 = filter(MS_pooled_summary[recur_ind,], !ID %in% indiv_removed)
writeLines('\nNumber of individuals with at least one paired recurrence typed and analysed by treatment:')
table(X0[!duplicated(X0$ID),'trial_arm_partner'])[treatment_order]
writeLines('\nPercent of Nr individuals with at least one paired recurrence typed  and analysed by treatment:') 
round(100*table(X0[!duplicated(X0$ID),'trial_arm_partner'])[names(Nr)]/Nr)[treatment_order]

recur_ind = MS_pooled_summary$Episode > 1
X0 = filter(MS_pooled_summary[recur_ind,], !Episode_Identifier %in% recur_removed)
writeLines('\nNumber of paired recurrences typed by treatment:')
table(X0$trial_arm_partner)[treatment_order]
writeLines('\nPercent of paired recurrences typed by treatment:') 
round(100*table(X0$trial_arm_partner)[names(R)]/R)[treatment_order] 
```


```{r CoatneyStylePLot, echo=FALSE}
# Only the recurrences for which we can compute estimates of recurrence state
MS_final = filter(MS_pooled_summary, !is.na(L_median))
MS_final = arrange(MS_final, desc(Drug), desc(FU), desc(TotalEpisodes))
ids = unique(MS_final$ID)

if(CREATE_PLOTS){
  
  ## Time series data colored by genetic STATE: classification
  mycols_states_bg = c('#000000FF',"#0000FFFF",'#FFFFFFFF') # colors for states - inc. uncertain
  mycols_states_fg = c("#000000FF","#0000FFFF",Dark2[8]) # colors for states - inc. uncertain 
  mycols_drugs = brewer.pal(n=3, name = 'Set1')
  par(las=1, bty='n', cex.axis=.3, mar=c(4,0,1,1), family = 'serif')
  plot(NULL, ylab = '', xlab = '',
       xlim = c(0,370), 
       ylim = c(1,length(ids)),
       xaxt='n', yaxt='n')
  mtext(text = 'Months from start of study', side = 1, line=2.5, cex=1)
  axis(1, at = seq(0,370, by=60), labels = seq(0,370, by=60)/30, cex.axis=1)
  
  for(i in 1:length(ids)){
    
    id = ids[i]
    ind = which(MS_final$ID==id)
    
    # Add the follow up time line
    lines(c(0,MS_final$FU[ind[1]]), 
          c(i,i), lty=1, 
          lwd=.5, col=drug_cols2[MS_final$Drug[ind[1]]])
    
    # For highlighting long-latency
    # Add the follow up time line
    if(id == 'VHX_235' | id == 'BPD_27'){
      lines(c(0,MS_final$FU[ind[1]]), 
            c(i,i), lty = 'dashed', 
            lwd=.5, col= 'black')
      cols = mycols_states_fg[MS_final$Plotting_col_Values[ind]]
      points(MS_final$timeSinceEnrolment[tail(ind,1)], i, 
             pch=1,cex = 1.5, 
             col='black')
    }
    
    # Add points after highlight lines
    points(MS_final$timeSinceEnrolment[ind], rep(i,length(ind)), 
           pch=MS_final$Plotting_pch_Values[ind], 
           bg=mycols_states_bg[MS_final$Plotting_col_Values[ind]],
           col=mycols_states_fg[MS_final$Plotting_col_Values[ind]], 
           cex=.6)
    
  }
  lines(x = c(0,0), y = c(0,length(ids)),lwd=3)
  
  legend('topright', col = c(mycols_states_fg), 
         pch = c(17,15,6), cex = 1, bty = 'n', y.intersp = 0.75, title = 'Classification',
         legend = c('Relapse','Uncertain','Reinfection'))
  
  legend('top', col = drug_cols2[2:3], 
         cex = 1, bty = 'n', y.intersp = 0.75, 
         lty = 1, lwd = 1,
         legend = c('No PMQ', 'PMQ+'))
}

writeLines(sprintf('The Coatney style plot is showing %s recurrences in %s individuals',
                   nrow(MS_final), length(ids)))
```

We show a histogram representation of these classification outputs as suggested by reviewer:
```{r histogram_representation_classification}
par(las=1, mfcol=c(3,2))
hist(MS_final$timeSinceEnrolment[MS_final$Plotting_col_Values==1 &
                                   MS_final$Treatment != 'PMQ'],
     main = 'No PMQ: classified relapses', xlab = 'Months from start of study',
     xaxt='n', ylab = 'Number of recurrences',  col = 'black', border = 'white',
     breaks = seq(0, 390, by = 14))
axis(1, at = 30*(0:12), labels = 0:12)
hist(MS_final$timeSinceEnrolment[MS_final$Plotting_col_Values==2 &
                                   MS_final$Treatment != 'PMQ'],
     main = 'No PMQ: uncertain classification',  ylab = 'Number of recurrences',
     xlab = 'Months from start of study', xaxt='n', yaxt='n',
     breaks = seq(0, 390, by = 14), col = mycols_states_bg[2])
axis(1, at = 30*(0:12), labels = 0:12)
axis(2, at = 0:2)
plot(NA,NA,xlab='',ylab='',xlim=c(0,1),ylim=c(0,1),xaxt='n',yaxt='n',bty='n')

hist(MS_final$timeSinceEnrolment[MS_final$Plotting_col_Values==1 &
                                   MS_final$Treatment == 'PMQ'],
     main = 'PMQ+: classified relapses', ylab = 'Number of recurrences',
     xlab = 'Months from start of study', xaxt='n',yaxt='n',
     breaks = seq(0, 390, by = 14), col = 'black', border = 'white')
axis(1, at = 30*(0:12), labels = 0:12)
axis(2, at = 0:2)
hist(MS_final$timeSinceEnrolment[MS_final$Plotting_col_Values==2 &
                                   MS_final$Treatment == 'PMQ'],
     main = 'PMQ+: uncertain classification',ylab = 'Number of recurrences', 
     xlab = 'Months from start of study', xaxt='n',
     col = mycols_states_bg[2],breaks = seq(0, 390, by = 14))
axis(1, at = 30*(0:12), labels = 0:12)

hist(MS_final$timeSinceEnrolment[MS_final$Plotting_col_Values==3 &
                                   MS_final$Treatment == 'PMQ'],
     main = 'PMQ+: classified reinfections',ylab = 'Number of recurrences', 
     xlab = 'Months from start of study', xaxt='n',
     breaks = seq(0, 390, by = 14))
axis(1, at = 30*(0:12), labels = 0:12)
```


```{r CompleteDataPlot, fig.height=7, fig.width=7, echo=FALSE}
if(CREATE_PLOTS){
  
  par(las=1, mfcol = c(2,1), mar=c(4,4,1,1), bty='n', family = 'serif')
  MS_final = arrange(MS_final, L_median)
  
  plot(NULL,
       xlim = c(1,nrow(MS_final)), 
       ylim = c(0,1),
       panel.first = grid(),  
       yaxt='n', ylab='', xlab = '')
  mtext(text = 'Recurrence rank',side = 1, line = 2)
  axis(2, at = c(0,.5,1))
  title(ylab = 'Relapse posterior probability', line = 3)
  polygon(x = c(-100,nrow(MS_final)+100,nrow(MS_final)+100,-100),
          y = c(Epsilon_lower,Epsilon_lower,Epsilon_upper,Epsilon_upper),
          col = transparent_blue_band, border = NA)
  
  
  segments(x0 = 1:nrow(MS_final), 
           x1 = 1:nrow(MS_final), 
           y0 = MS_final$L_lower,
           y1 = MS_final$L_upper,
           col = drug_cols_light2[MS_final$Drug])
  
  # Superimposed points
  points(1:nrow(MS_final),
         MS_final$L_median, 
         col = drug_cols2[MS_final$Drug], 
         pch=20, cex=.8)
  
  legend(x=0.8*nrow(MS_final), y = 0.8, col = drug_cols2[2:3], 
         pch = 20, cex = 1.2, bty = 'o', border = 'white',
         legend = c('No PMQ','PMQ+'))
  
  # Against time
  plot(NULL, 
       xlim = range(MS_final$timeSinceLastEpisode), 
       ylim = c(0,1),
       panel.first = grid(), 
       xlab = '',ylab = '',yaxt='n', xaxt='n')
  axis(2, at = c(0,.5,1))
  axis(1, at = seq(0, 360, by =60), labels = seq(0, 360, by=60)/30)
  title(xlab = '', ylab = 'Relapse posterior probability', line = 3)
  mtext(text = 'Months since last episode', side = 1, line = 2)
  polygon(x = c(-10,max(MS_final$timeSinceLastEpisode)+100,
                max(MS_final$timeSinceLastEpisode)+100,-10),
          y = c(Epsilon_lower,Epsilon_lower,Epsilon_upper,Epsilon_upper),
          col = transparent_blue_band, border = NA)
  for(i in 1:nrow(MS_final)){
    
    if(abs(MS_final$L_upper[i] - MS_final$L_lower[i]) > 0.005){
      segments(x0 = MS_final$timeSinceLastEpisode[i],
               y0 = MS_final$L_lower[i],
               x1=MS_final$timeSinceLastEpisode[i],
               y1 = MS_final$L_upper[i],
               col=drug_cols_light2[MS_final$Drug[i]])
    }
    i=i+1
  }
  
  # Add points
  points(MS_final$timeSinceLastEpisode, MS_final$L_median,
         col = drug_cols2[MS_final$Drug], 
         pch=20, cex=.8)
  
  
  legend(x=0.8*max(MS_final$timeSinceLastEpisode), y = 0.8, col = drug_cols2[2:3], 
         pch = 20, cex = 1.2, bty = 'o', border = 'white', 
         legend = c('No PMQ','PMQ+'))
  
  
}
```

Individuals who appear to relapse very late (more than 300 days after last episode):
```{r}
MS_pooled = reformat_MSdata(MS_pooled)
IDs_late_relapse = MS_final[which(MS_final$timeSinceLastEpisode>300 & MS_final$L_lower>.9),'ID']

writeLines(sprintf('The episode ids of interest are: %s',
                   MS_final[which(MS_final$timeSinceLastEpisode>300 & MS_final$L_lower>.9),
                            'Episode_Identifier']))
print(MS_pooled[MS_pooled$ID%in%IDs_late_relapse,])
```


The summaries of the final dataset. Results for all those genotyped who did not receive primaquine (artesunate or chloroquine monotherapy):
```{r, echo = FALSE}
table(MS_final$Treatment[!duplicated(MS_final$ID)]) # 208 individuals overall
```

```{r, echo=FALSE}
ind_noPMQ = MS_final$Treatment=='AS' | MS_final$Treatment=='CHQ'
writeLines(sprintf('In no-primaquine individuals, the weighted average of relapse is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$L_median[ind_noPMQ])/sum(ind_noPMQ),1),
                   round(100*sum(MS_final$L_lower[ind_noPMQ])/sum(ind_noPMQ),1),
                   round(100*sum(MS_final$L_upper[ind_noPMQ])/sum(ind_noPMQ),1),
                   sum(ind_noPMQ)))

writeLines(sprintf('In no-primaquine individuals, the weighted average of recrudescences is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$C_median[ind_noPMQ],na.rm=T)/sum(ind_noPMQ),1),
                   round(100*sum(MS_final$C_lower[ind_noPMQ],na.rm=T)/sum(ind_noPMQ),1),
                   round(100*sum(MS_final$C_upper[ind_noPMQ],na.rm=T)/sum(ind_noPMQ),1),
                   sum(ind_noPMQ)))

writeLines(sprintf('In no-primaquine individuals, the weighted average of reinfections is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$I_median[ind_noPMQ],na.rm=T)/sum(ind_noPMQ),1),
                   round(100*sum(MS_final$I_lower[ind_noPMQ],na.rm=T)/sum(ind_noPMQ),1),
                   round(100*sum(MS_final$I_upper[ind_noPMQ],na.rm=T)/sum(ind_noPMQ),1),
                   sum(ind_noPMQ)))

```

Results for all those genotyped who did receive primaquine (VHX and BPD studies combined):
```{r, echo=FALSE}
ind_PMQ = MS_final$Treatment=='PMQ'
writeLines(sprintf('In primaquine treated individuals, the weighted average of relapses is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$L_median[ind_PMQ])/sum(ind_PMQ),1),
                   round(100*sum(MS_final$L_lower[ind_PMQ])/sum(ind_PMQ),1),
                   round(100*sum(MS_final$L_upper[ind_PMQ])/sum(ind_PMQ),1),
                   sum(ind_PMQ)))

writeLines(sprintf('In primaquine treated individuals, the weighted average of recrudescences is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$C_median[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   round(100*sum(MS_final$C_lower[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   round(100*sum(MS_final$C_upper[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   sum(ind_PMQ)))

writeLines(sprintf('In primaquine treated individuals, the weighted average of reinfections is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$I_median[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   round(100*sum(MS_final$I_lower[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   round(100*sum(MS_final$I_upper[ind_PMQ],na.rm=T)/sum(ind_PMQ),1),
                   sum(ind_PMQ)))
```

Results for all those genotyped who did receive primaquine in the VHX study (unknown denominator)
```{r, echo=FALSE}
ind_PMQ_VHX = intersect(which(MS_final$Treatment=='PMQ'), grep('VHX',MS_final$ID))
writeLines(sprintf('In primaquine treated individuals (VHX), the weighted average of relapses is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$L_median[ind_PMQ_VHX])/length(ind_PMQ_VHX),1),
                   round(100*sum(MS_final$L_lower[ind_PMQ_VHX])/length(ind_PMQ_VHX),1),
                   round(100*sum(MS_final$L_upper[ind_PMQ_VHX])/length(ind_PMQ_VHX),1),
                   length(ind_PMQ_VHX)))

writeLines(sprintf('In primaquine treated individuals (VHX), the weighted average of recrudescences is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$C_median[ind_PMQ_VHX],na.rm=T)/length(ind_PMQ_VHX),1),
                   round(100*sum(MS_final$C_lower[ind_PMQ_VHX],na.rm=T)/length(ind_PMQ_VHX),1),
                   round(100*sum(MS_final$C_upper[ind_PMQ_VHX],na.rm=T)/length(ind_PMQ_VHX),1),
                   length(ind_PMQ_VHX)))

writeLines(sprintf('In primaquine treated individuals (VHX), the weighted average of reinfections is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$I_median[ind_PMQ_VHX],na.rm=T)/length(ind_PMQ_VHX),1),
                   round(100*sum(MS_final$I_lower[ind_PMQ_VHX],na.rm=T)/length(ind_PMQ_VHX),1),
                   round(100*sum(MS_final$I_upper[ind_PMQ_VHX],na.rm=T)/length(ind_PMQ_VHX),1),
                   length(ind_PMQ_VHX)))

```

Results for all those genotyped who did receive primaquine in the BPD study (known denominator)
```{r, echo=FALSE}
ind_PMQ_BPD = intersect(which(MS_final$Treatment=='PMQ'), grep('BPD',MS_final$ID))
writeLines(sprintf('In primaquine treated individuals (BPD), the weighted average of relapses is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$L_median[ind_PMQ_BPD])/length(ind_PMQ_BPD),1),
                   round(100*sum(MS_final$L_lower[ind_PMQ_BPD])/length(ind_PMQ_BPD),1),
                   round(100*sum(MS_final$L_upper[ind_PMQ_BPD])/length(ind_PMQ_BPD),1),
                   length(ind_PMQ_BPD)))

writeLines(sprintf('In primaquine treated individuals (BPD), the weighted average of recrudescences is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$C_median[ind_PMQ_BPD],na.rm=T)/length(ind_PMQ_BPD),3),
                   round(100*sum(MS_final$C_lower[ind_PMQ_BPD],na.rm=T)/length(ind_PMQ_BPD),3),
                   round(100*sum(MS_final$C_upper[ind_PMQ_BPD],na.rm=T)/length(ind_PMQ_BPD),3),
                   length(ind_PMQ_BPD)))

writeLines(sprintf('In primaquine treated individuals (BPD), the weighted average of reinfections is %s (%s-%s), for %s recurrences',
                   round(100*sum(MS_final$I_median[ind_PMQ_BPD],na.rm=T)/length(ind_PMQ_BPD),1),
                   round(100*sum(MS_final$I_lower[ind_PMQ_BPD],na.rm=T)/length(ind_PMQ_BPD),1),
                   round(100*sum(MS_final$I_upper[ind_PMQ_BPD],na.rm=T)/length(ind_PMQ_BPD),1),
                   length(ind_PMQ_BPD)))

```

# False positive rate of relapse

We want to know how often our model estimates evidence of relapse across pairs of episodes when the episodes are in different people (i.e. have no possibility of being a relapse)

```{r}
if(RUN_MODELS_FALSE_POSITIVE){
  # check if the massive pairwise dataset has been made, if not make it 
  # (takes a long time ~20hours)
  if(!"APC_MSdata.bigRData"%in%list.files(path = '../RData/LargeFiles/')){
    # The pooled MS data from BPD and VHX
    load('../RData/GeneticModel/MS_data_PooledAnalysis.RData')
    tic()
    APC_MSdata = Make_All_Pairwise_Comparisons(MS_data = MS_pooled, ncores=42)
    save(APC_MSdata, file = '../RData/LargeFiles/APC_MSdata.bigRData')
    toc()
  } 
  load('../RData/LargeFiles/APC_MSdata.bigRData')
  print('The inflated pairwise dataset is available, now running the analysis...')
  # Run the genetic model on the pairwise data
  tic()
  Inflated_Results = post_prob_CLI(MSdata = APC_MSdata, 
                                   Fs = Fs_Combined, 
                                   UpperComplexity = 10^6, 
                                   verbose = T,
                                   cores = Ncores)
  toc()
  save(Inflated_Results, file = '../RData/LargeFiles/Inflated_Results.bigRData')
} else {
  load('../RData/LargeFiles/Inflated_Results.bigRData')
  Inflated_Results = Inflated_Results[!is.na(Inflated_Results$L),]
  load('../RData/LargeFiles/APC_MSdata.bigRData')
}
```


```{r, echo=FALSE}
writeLines(sprintf('The false-positive discovery rate of the genetic model is estimated as %s percent. 
                   \nThis is based on %s pairwise comparisons',
                   round(100*sum( Inflated_Results$L > Epsilon_upper,
                                  na.rm = T)/sum(!is.na(Inflated_Results$L)),2),
                   nrow(Inflated_Results)))
```




# Summaries of numbers of markers typed by classified recurrent samples 

```{r}
# Check that the episodes missing from MS_final are only those that were too complex: yes
inds = MS_typd$Episode[which(!MS_typd$Episode_Identifier %in% MS_final$Episode_Identifier)] > 1 
missing_from_MS_final = MS_typd$Episode_Identifier[which(!MS_typd$Episode_Identifier %in% MS_final$Episode_Identifier)][inds] 
all(recur_removed == missing_from_MS_final)

#==========================================================================
# Classification of recurrent episodes genotyped at any markers
#==========================================================================
ind_classified = MS_final$Episode_Identifier %in% names(MS_typd_count)
recur_count = MS_typd_count[MS_final$Episode_Identifier[ind_classified]]
recur_typed_class = paste(recur_count, MS_final$L_or_C_state[ind_classified])
#table(recur_typed_class) # Table of number marks successful and classification

#==========================================================================
# Classification of recurrent episodes genotyped at additional markers
#==========================================================================
names_additional = names(MS_addn_count_recurrent) # Names of all 
ind_classified = MS_final$Episode_Identifier %in% names_additional
recur_add_count = MS_addn_count_recurrent[MS_final$Episode_Identifier[ind_classified]]
recur_add_typed_class = paste(recur_add_count, MS_final$L_or_C_state[ind_classified])
ind_add_classified = MS_final$Episode_Identifier %in% names(which(MS_addn_count_recurrent > 1))

BPD_ind = grepl('BPD_', MS_final$ID) # Index for BPD individuals
VHX_ind = grepl('VHX_', MS_final$ID) # Index for VHX individuals

writeLines(sprintf('\nParition of %s recurrences analysed partioned by number of additional markers successfully typed:',
                   sum(table(recur_add_count))))
table(recur_add_count)


writeLines(sprintf('\nClassification of %s recurrences analysed partioned by number of additional markers successfully typed:',
                   sum(table(recur_add_typed_class))))
table(recur_add_typed_class)

writeLines(sprintf('\nOf those recurrent genotyped at additional markers: %s of %s (%s percent, %s VHX, %s BPD) classified as relapse',
                   sum(MS_final$L_or_C_state[ind_add_classified] == 'L'), 
                   sum(ind_add_classified),
                   round(100*sum(MS_final$L_or_C_state[ind_add_classified] == 'L')/sum(ind_add_classified)), 
                   sum(MS_final$L_or_C_state[VHX_ind][ind_add_classified[VHX_ind]] == 'L'),
                   sum(MS_final$L_or_C_state[BPD_ind][ind_add_classified[BPD_ind]] == 'L'))) 
```

Plots over classified recurrent samples 

```{r}
#==========================================================================
# Classification plots: why are some points beyond the uncertainity zone classified 
# as uncertain
#==========================================================================
par(mfrow = c(2,1), family = 'serif')

plot(x = recur_add_count + rnorm(length(recur_add_count), 0, 0.025), # Add jitter 
     y = MS_final$L_median[ind_classified], 
     panel.first = grid(), 
     pch = MS_final$Plotting_pch_Values[ind_add_classified], 
     bg=mycols_states_bg[MS_final$Plotting_col_Values[ind_add_classified]],
     col=mycols_states_fg[MS_final$Plotting_col_Values[ind_add_classified]],
     ylab = 'Relapse posterior probability', 
     xlab = 'Number of additional markers successfully typed', 
     xaxt = 'n') # Number additional successful vs median relapse probablity
axis(side = 1, at = c(0,3:6)) # Add axis

# Add zone of uncertainity
polygon(x = c(-10,max(MS_final$timeSinceLastEpisode)+100,
              max(MS_final$timeSinceLastEpisode)+100,-10),
        y = c(Epsilon_lower,Epsilon_lower,Epsilon_upper,Epsilon_upper),
        col = transparent_blue_band, border = NA)

plot(x = recur_count + rnorm(length(recur_count), 0, 0.075), # Add jitter
     MS_final$L_median[ind_classified], 
     panel.first = grid(), 
     pch = MS_final$Plotting_pch_Values[ind_classified], 
     bg=mycols_states_bg[MS_final$Plotting_col_Values[ind_classified]],
     col=mycols_states_fg[MS_final$Plotting_col_Values[ind_classified]],
     ylab = 'Relapse posterior probability', 
     xlab = 'Number of markers successfully typed', 
     xaxt = 'n') # Number additional successful vs median relapse probablity
axis(side = 1, at = 1:9) # Add axis

# Add zone of uncertainity
polygon(x = c(-10,max(MS_final$timeSinceLastEpisode)+100,
              max(MS_final$timeSinceLastEpisode)+100,-10),
        y = c(Epsilon_lower,Epsilon_lower,Epsilon_upper,Epsilon_upper),
        col = transparent_blue_band, border = NA)
```





# Analysis of radical cure efficacy in BPD and VHX

Almost all recurrences in BPD were typed. The majority (34 out of 40) of the recurrences in VHX were typed also.
Therefore we can estimate the true efficacy of high-dose primaquine by adjusting for the background reinfection rates in both studies.

```{r}
# Add an episode identifier
Combined_Time_Data$Episode_Identifier = apply(Combined_Time_Data,1,
                                              function(x){paste(x['patientid'],as.integer(x['episode']),sep='_')})

# Create columns into which probabilities can be stored
Combined_Time_Data$Reinfection_Probability=
  Combined_Time_Data$Reinfection_Probability_LL=
  Combined_Time_Data$Reinfection_Probability_UL = NA

# Add an episode identifier
Mod2_ThetaEstimates$Failure_Identifier = apply(Mod2_ThetaEstimates, 1, 
                                               function(x) paste(x['patientid'],as.integer(x['episode']),sep='_'))

# Iterate over every episode and use either the joint posterior 
# or, if missing, the time probability, which could be time censored 
sss=0
for(i in 1:nrow(Combined_Time_Data)){
  
  ep_id = Combined_Time_Data$Episode_Identifier[i] # Extract episode id
  
  # we look one episode ahead
  MS_id = paste(Combined_Time_Data$patientid[i],as.integer(Combined_Time_Data$episode[i])+1, sep='_')
  
  # If in MS_final, we extract the full reinfection probability
  if(MS_id %in% MS_final$Episode_Identifier){
    
    Combined_Time_Data$Reinfection_Probability[i] =
      MS_final$I_median[MS_final$Episode_Identifier==MS_id]
    Combined_Time_Data$Reinfection_Probability_UL[i] =
      MS_final$I_upper[MS_final$Episode_Identifier==MS_id]
    Combined_Time_Data$Reinfection_Probability_LL[i] =
      MS_final$I_lower[MS_final$Episode_Identifier==MS_id]
    
  } else { # use the time to event model
    
    ind = which(Mod2_ThetaEstimates$Failure_Identifier==MS_id)
    
    if(length(ind)>0){
      
      Combined_Time_Data$Reinfection_Probability[i] =
        Mod2_ThetaEstimates$ReInfection_mean_theta[ind]
      Combined_Time_Data$Reinfection_Probability_UL[i] =
        Mod2_ThetaEstimates$ReInfection_975_theta[ind]
      Combined_Time_Data$Reinfection_Probability_LL[i] =
        Mod2_ThetaEstimates$ReInfection_025_theta[ind]
      sss=sss+1
    }
  }
}

```

## PK analysis with carboxy primaquine

Now we look at whether the PK (carboxy-primaquine) can predict failure:
First we add the carboxy to the dataset:
```{r}
Combined_Time_Data = arrange(Combined_Time_Data, patientid, episode)
load('../RData/PK_data/BPD_pk.RData')
BPD_pk = filter(BPD_pk, !is.na(Episode))
Combined_Time_Data$log10_carboxyPMQ = NA
Combined_Time_Data$log10_PMQ = NA
Combined_Time_Data$NumberDaysPMQ = NA
# The default is 14 days
Combined_Time_Data$NumberDaysPMQ[Combined_Time_Data$Censored != 1 &
                                   Combined_Time_Data$arm_num=='CHQ/PMQ'] = 14
for(i in 1:nrow(Combined_Time_Data)){
  id = Combined_Time_Data$patientid[i]
  ep_i = Combined_Time_Data$episode[i]
  all_id_eps = Combined_Time_Data$episode[Combined_Time_Data$patientid==id]
  pk_ind = which(BPD_pk$ID == id & BPD_pk$Episode==ep_i)
  if(length(pk_ind)>0){
    if(length(pk_ind)>1) print(id)
    Combined_Time_Data$log10_carboxyPMQ[i] = mean(BPD_pk$log10_carboxyPQ_PK[pk_ind])
    Combined_Time_Data$log10_PMQ[i] = mean(BPD_pk$log10_PQ_PK[pk_ind])
    Combined_Time_Data$NumberDaysPMQ[i] = BPD_pk$NumberofPKDays[pk_ind[1]]
  }
}
```

We exclude the two recurrences seen in patient BPD_444 who was G6PD deficient and received the 8 weekly regimen (not daily dosing).

```{r CarboxyPredictionFailure}
# These are two outliers - have discussed with Cindy
BPD444_recurrences = Combined_Time_Data$patientid=='BPD_44' & Combined_Time_Data$episode>1
BPD_598 = which(Combined_Time_Data$patientid=='BPD_598')
ind_keep = !BPD444_recurrences #& !BPD_598
Combined_Time_Data$Failure_YN = Combined_Time_Data$Reinfection_Probability < 0.5
mod = glmer(Failure_YN ~ log10_carboxyPMQ + NumberDaysPMQ + 
              (1 | patientid), 
            family = 'binomial', data=Combined_Time_Data[ind_keep,])
summary(mod)
# Plot the data and model
xs=seq(0,4,by=.01)
par(las = 1, bty='n')
regimen_colors = brewer.pal(8, 'Dark2')[c(1,5)]
plot(Combined_Time_Data$log10_carboxyPMQ[ind_keep]*Combined_Time_Data$NumberDaysPMQ[ind_keep],
     jitter(as.numeric(Combined_Time_Data$Failure_YN[ind_keep]), factor = 0.02), 
     col = regimen_colors[mapvalues(Combined_Time_Data$NumberDaysPMQ[ind_keep],c(7,14),c(1,2))],
     pch = mapvalues(Combined_Time_Data$NumberDaysPMQ[ind_keep],c(7,14),c(3,4)),
     xlab = 'Carboxy-primaquine exposure: days * log(ng/mL)',
     panel.first = grid(), ylab = 'Probability of failure')
legend(x = 40, y = 0.3, bty='n', col =regimen_colors, 
       pch=c(3,4), legend = c('7 days','14 days'))
lines(xs*7, predict(mod, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=7,
                                            patientid='new'),allow.new.levels=T,
                    type='response'), lwd=2, col= regimen_colors[1], lty=2)
lines(xs*14, predict(mod, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=14,
                                             patientid='new'),allow.new.levels=T,
                     type='response'), lwd=2, col= regimen_colors[2], lty = 2)
points(Combined_Time_Data$log10_carboxyPMQ[BPD_598]*Combined_Time_Data$NumberDaysPMQ[BPD_598],
       Combined_Time_Data$Failure_YN[BPD_598], cex=2)
text(Combined_Time_Data$log10_carboxyPMQ[BPD_598[1]]*
       Combined_Time_Data$NumberDaysPMQ[BPD_598[1]]+3,
     Combined_Time_Data$Failure_YN[BPD_598[1]]-0.05, labels = 'BPD_598')
```

Now we remove outliers and fit the same model (CPMQ outliers)
```{r}
mu_hat_7 = mean(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==7])
sd_hat_7 = sd(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==7])
mu_hat_14 = mean(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==14],na.rm=T)
sd_hat_14 = sd(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==14],na.rm=T)

par(mfrow=c(1,2))
hist(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==7],
     main='', xlab='carboxy primaquine day 7 (ng/mL)')
abline(v = mu_hat_7 - sd_hat_7*3)

hist(Combined_Time_Data$log10_carboxyPMQ[Combined_Time_Data$NumberDaysPMQ==14],
     main = '', xlab='carboxy primaquine day 7 (ng/mL)')
abline(v = mu_hat_14 - sd_hat_14*3)

outliers7 = Combined_Time_Data$NumberDaysPMQ==7 & Combined_Time_Data$log10_carboxyPMQ<mu_hat_7 - sd_hat_7*3
outliers14 = Combined_Time_Data$NumberDaysPMQ==14 & Combined_Time_Data$log10_carboxyPMQ<mu_hat_14 - sd_hat_14*3

mod_No_Outliers = glmer(Failure_YN ~ log10_carboxyPMQ + NumberDaysPMQ + 
                          (1 | patientid), 
                        family = 'binomial', data=Combined_Time_Data[ind_keep & !outliers14 & !outliers7,])
summary(mod_No_Outliers)
```

Compare results with and without outliers:

```{r CarboxyPredictionFailure_NoOutliers}
par(las = 1, bty='n')
plot(Combined_Time_Data$log10_carboxyPMQ[ind_keep]*Combined_Time_Data$NumberDaysPMQ[ind_keep],
     jitter(as.numeric(Combined_Time_Data$Failure_YN[ind_keep]),factor = 0.03), 
     col = regimen_colors[mapvalues(Combined_Time_Data$NumberDaysPMQ[ind_keep],c(7,14),1:2)],
     pch = mapvalues(Combined_Time_Data$NumberDaysPMQ[ind_keep],c(7,14),c(3,4)),
     xlab = 'Carboxy-primaquine trough exposure: days * log(ng/mL)',
     ylab = 'Probability of failure', panel.first = grid())
legend(x = 25, y = 0.7, bty='n', col = c(1, regimen_colors, 1,1),
       pch=c(1,3,4,NA,NA), lty = c(NA,NA,NA,1,2),lwd=c(NA,NA,NA,2,2),
       legend = c('Outlier','7 days','14 days',
                  'Regression fit: all data', 'Regression fit: outliers removed'))
lines(xs*7, predict(mod, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=7,
                                            patientid='new'),allow.new.levels=T,
                    type='response'), lwd=2, col= regimen_colors[1], lty=1)
lines(xs*14, predict(mod, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=14,
                                             patientid='new'),allow.new.levels=T,
                     type='response'), lwd=2, col= regimen_colors[2], lty = 1)

lines(xs*7, predict(mod_No_Outliers, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=7,
                                                        patientid='new'),allow.new.levels=T,
                    type='response'), lwd=2, col= regimen_colors[1], lty=2)
lines(xs*14, predict(mod_No_Outliers, newdata=data.frame(log10_carboxyPMQ=xs, NumberDaysPMQ=14,
                                                         patientid='new'),allow.new.levels=T,
                     type='response'), lwd=2, col= regimen_colors[2], lty = 2)

# outline the outliers
points(Combined_Time_Data$log10_carboxyPMQ[outliers14|outliers7]*Combined_Time_Data$NumberDaysPMQ[outliers14|outliers7],
       Combined_Time_Data$Failure_YN[outliers14|outliers7], cex=2)
```

## Failures after PMQ+

Now we calculate a compressed dataset and failure for each individual

```{r}
# now we calculate the primaquine failure rate
# For individuals with two episodes: P(failure) = 1 - P(Rec 1 = I)*P(Rec 2 = I)
Summary_data = Combined_Time_Data[!duplicated(Combined_Time_Data$patientid),]
Summary_data$N_typed = NA
for(id in unique(Summary_data$patientid)){
  if(!(id %in% MS_pooled$ID)){
    Summary_data$N_typed[Summary_data$patientid==id]=0
  } else {
    Summary_data$N_typed[Summary_data$patientid==id] =  
      sum(apply(MS_pooled[MS_pooled$ID==id, MSs_all],2, 
                function(x) sum(is.na(x))) == 0)
  }
}

Summary_data$Failure_UL = Summary_data$Failure_LL = 
  Summary_data$Failure = Summary_data$CPMQ = 
  Summary_data$CPMQ = NA
for(i in 1:nrow(Summary_data)){
  ind = which(Combined_Time_Data$patientid==Summary_data$patientid[i])
  Summary_data$Failure[i] = 1-prod(Combined_Time_Data$Reinfection_Probability[ind],na.rm=T)
  Summary_data$Failure_UL[i] = 1-prod(Combined_Time_Data$Reinfection_Probability_UL[ind],na.rm=T)
  Summary_data$Failure_LL[i] = 1-prod(Combined_Time_Data$Reinfection_Probability_LL[ind],na.rm=T)
  Summary_data$CPMQ[i] = median(Combined_Time_Data$log10_carboxyPMQ[ind],na.rm=T)
}
VHX_PMQ_data = filter(Summary_data, Study_Period==1, arm_num=='CHQ/PMQ')
BPD_data = filter(Summary_data, Study_Period==2)

P_Failure=100*sum(BPD_data$Failure)/nrow(BPD_data)
# invert the intervals here - optimistic for not failure = pessimistic for failure
P_Failure_UL = 100*sum(BPD_data$Failure_LL)/nrow(BPD_data)
P_Failure_LL = 100*sum(BPD_data$Failure_UL)/nrow(BPD_data)

writeLines(sprintf('In BPD, the primaquine failure rate in the %s individuals is %s%% (%s-%s) over the course of %s years total follow-up.',
                   nrow(BPD_data), round(P_Failure,1),
                   round(P_Failure_LL,1),
                   round(P_Failure_UL,1), round(sum(BPD_data$FU_time)/365)))

P_Failure_VHX=100*sum(VHX_PMQ_data$Failure)/nrow(VHX_PMQ_data)
# invert the intervals here - optimistic for not failure = pessimistic for failure
P_Failure_UL_VHX = 100*sum(VHX_PMQ_data$Failure_LL)/nrow(VHX_PMQ_data)
P_Failure_LL_VHX = 100*sum(VHX_PMQ_data$Failure_UL)/nrow(VHX_PMQ_data)

writeLines(sprintf('In VHX, the primaquine failure rate in the %s individuals is %s%% (%s-%s) over the course of %s years total follow-up.',
                   nrow(VHX_PMQ_data), round(P_Failure_VHX,1),
                   round(P_Failure_LL_VHX,1),
                   round(P_Failure_UL_VHX,1), round(sum(VHX_PMQ_data$FU_time)/365)))

mean(Combined_Time_Data$Reinfection_Probability[Combined_Time_Data$Study_Period==1 &
                                                  Combined_Time_Data$arm_num=='CHQ/PMQ' &
                                                  Combined_Time_Data$Censored==0],na.rm=T)

mean(Combined_Time_Data$Reinfection_Probability[Combined_Time_Data$Study_Period==2 &
                                                  Combined_Time_Data$arm_num=='CHQ/PMQ' &
                                                  Combined_Time_Data$Censored==0],na.rm=T)

PMQ_data = filter(Summary_data, arm_num == 'CHQ/PMQ')

P_Failure_all=100*sum(PMQ_data$Failure)/nrow(PMQ_data)
# invert the intervals here - optimistic for not failure = pessimistic for failure
P_Failure_UL_all = 100*sum(PMQ_data$Failure_LL)/nrow(PMQ_data)
P_Failure_LL_all = 100*sum(PMQ_data$Failure_UL)/nrow(PMQ_data)
writeLines(sprintf('In all primaquine treated individuals, the failure rate in the %s individuals is %s%% (%s-%s) over the course of %s years total follow-up.',
                   nrow(PMQ_data), round(P_Failure_all,1),
                   round(P_Failure_LL_all,1),
                   round(P_Failure_UL_all,1), round(sum(PMQ_data$FU_time)/365)))
```

The above failure rate is based on all available data. Next we consider rates based on adjustments using time and genetic only. 

```{r}
# First create columns into which probabilities can be stored
Combined_Time_Data$Reinfection_Probability_time_only =
  Combined_Time_Data$Reinfection_Probability_UL_time_only =
  Combined_Time_Data$Reinfection_Probability_LL_time_only = NA

# Iterate over every episode using the time probability
sss=0
for(i in 1:nrow(Combined_Time_Data)){
  
  # Extract episode id
  ep_id = Combined_Time_Data$Episode_Identifier[i] 
  
  # we look one episode ahead (MS_id) and locate MS_id in time results
  MS_id = paste(Combined_Time_Data$patientid[i],as.integer(Combined_Time_Data$episode[i])+1, sep='_')
  ind = which(Mod2_ThetaEstimates$Failure_Identifier==MS_id)
  
  if(length(ind)>0){
    Combined_Time_Data$Reinfection_Probability_time_only[i] = Mod2_ThetaEstimates$ReInfection_mean_theta[ind]
    Combined_Time_Data$Reinfection_Probability_UL_time_only[i] = Mod2_ThetaEstimates$ReInfection_975_theta[ind]
    Combined_Time_Data$Reinfection_Probability_LL_time_only[i] = Mod2_ThetaEstimates$ReInfection_025_theta[ind]
    sss = sss + 1
  }
}


# now we calculate the primaquine failure rate for individuals with two episodes: P(failure) = 1 - P(Recurrence 1 = I)*P(Recurrence 2 = I)
Summary_data$Failure_UL_time_only = Summary_data$Failure_LL_time_only = Summary_data$Failure_time_only= NA
for(i in 1:nrow(Summary_data)){
  ind = which(Combined_Time_Data$patientid==Summary_data$patientid[i])
  Summary_data$Failure_time_only[i] = 1-prod(Combined_Time_Data$Reinfection_Probability_time_only[ind],na.rm=T)
  Summary_data$Failure_UL_time_only[i] = 1-prod(Combined_Time_Data$Reinfection_Probability_UL_time_only[ind],na.rm=T)
  Summary_data$Failure_LL_time_only[i] = 1-prod(Combined_Time_Data$Reinfection_Probability_LL_time_only[ind],na.rm=T)
}

# Filter s.t. only BPD data 
BPD_data = Summary_data[grep('BPD', Summary_data$patientid),]

# now we add the primaquine failure rate for BPD individuals, using genetic data only
BPD_data$Failure_UL_gene_only = BPD_data$Failure_LL_gene_only = BPD_data$Failure_gene_only = 0
for(i in 1:nrow(BPD_data)){
  pid = BPD_data$patientid[i]
  ind = grep(paste0(pid,'_'), thetas_9MS_Tagnostic$Episode_Identifier) 
  if(any(ind)){
    BPD_data$Failure_gene_only[i] = 1-prod(thetas_9MS_Tagnostic$I[ind])
    BPD_data$Failure_UL_gene_only[i] = 1-prod(thetas_9MS_Tagnostic$`I97.5%`[ind])
    BPD_data$Failure_LL_gene_only[i] = 1-prod(thetas_9MS_Tagnostic$`I2.5%`[ind])
  }
}

# Point estimate
P_Failure_time_only=100*sum(BPD_data$Failure_time_only)/nrow(BPD_data)
P_Failure_gene_only=100*sum(BPD_data$Failure_gene_only)/nrow(BPD_data)

# invert the intervals here - optimistic for not failure = pessimistic for failure
P_Failure_UL_time_only = 100*sum(BPD_data$Failure_LL_time_only)/nrow(BPD_data)
P_Failure_LL_time_only = 100*sum(BPD_data$Failure_UL_time_only)/nrow(BPD_data)
P_Failure_UL_gene_only = 100*sum(BPD_data$Failure_LL_gene_only)/nrow(BPD_data)
P_Failure_LL_gene_only = 100*sum(BPD_data$Failure_UL_gene_only)/nrow(BPD_data)

writeLines(sprintf('The primaquine failure rate, based on the joint model, in the %s individuals is %s%% (%s-%s) over the course of %s years total follow-up.',
                   nrow(BPD_data), round(P_Failure,2),
                   round(P_Failure_LL,2),
                   round(P_Failure_UL,2), round(sum(BPD_data$FU_time)/365)))

writeLines(sprintf('The primaquine failure rate, based on time-to-event model only, in the %s individuals is %s%% (%s-%s) over the course of %s years total follow-up.',
                   nrow(BPD_data), round(P_Failure_time_only,2),
                   round(P_Failure_LL_time_only,2),
                   round(P_Failure_UL_time_only,2), round(sum(BPD_data$FU_time)/365)))

writeLines(sprintf('The primaquine failure rate, based on genetic model only, in the %s individuals is %s%% (%s-%s) over the course of %s years total follow-up.',
                   nrow(BPD_data), round(P_Failure_gene_only,2),
                   round(P_Failure_LL_gene_only,2),
                   round(P_Failure_UL_gene_only,2), round(sum(BPD_data$FU_time)/365)))
```


```{r genetic_vers_timing_BPD}
par(las=1)
ind = BPD_data$Failure_gene_only>0
plot(BPD_data$Failure_time_only[ind],
     BPD_data$Failure_gene_only[ind],
     xlab='Time to event estimate', ylab = 'Genetic alone estimate',
     xlim=c(0,1),ylim=c(0,1), col  = BPD_data$N_typed[ind])
lines(0:1,0:1,lty=2)
legend('bottomright', pch = 1, col = c(3,9), legend = c('3 markers', '9 markers'))
```

save augmented summary data for other analyses
```{r}
save(Summary_data, file = '../RData/Summary_data_ModelResults.RData')
```

# Extra Analyses

## Looking at the effect of inbreeding coefficient

Our model has a parameter $\alpha$ which defines the level of inbreeding within the population.
Taylor is developing methods for the estimation of $\alpha$ from genetic data (in preparation).

We look at the sensitivity of the results (all the above is with $\alpha=0$) for a reasonable upper bound of $\alpha=0.175$.

We rerun the analysis on the single run isolates (low computational complexity):

```{r}
alphaUpper = 0.175
f_name = paste(f_name_prefix, 'thetas_9MS_alphaUpper.RData', sep='_')
if(RUN_MODELS_FULL_POSTERIOR){
  #===============================================
  # Run (with time-to-event)
  #===============================================
  # Approx 100 secs per full model run
  tic()
  thetas_9MS_alphaUpper = post_prob_CLI(MSdata = MS_pooled, Fs = Fs_Combined, 
                                        p = p, cores = 6, verbose = F, alpha = alphaUpper) 
  thetas_9MS_alphaUpper$Episode_Identifier = rownames(thetas_9MS_alphaUpper)
  save(thetas_9MS_alphaUpper, file = f_name)
  toc()
} else {
  load(f_name)
}
```

```{r}
par(las=1, bty='n', mfrow=c(2,2))
plot(thetas_9MS$L, 
     thetas_9MS_alphaUpper$L,
     log = 'xy',
     ylab = 'Relapse: inbred',
     xlab = 'Relapse: no inbreeding',
     col= drug_cols2[thetas_9MS$drug],pch=20)
lines(c(-10,10),c(-10,10),lty=2)

plot(log10(thetas_9MS$L), log10(thetas_9MS$L)-log10(thetas_9MS_alphaUpper$L),
     ylab = 'Difference in Log Relapse Probabilities',
     xlab = 'Relapse Probability: no inbreeding',
     col= drug_cols2[thetas_9MS$drug],pch=20)
abline(h=0,lty=2)
legend('topleft', legend = c('No PMQ', 'PMQ+'), col = drug_cols2[2:3], pch = 20, bty = 'n')

###****** Reinfection : comparison *****#####
par(las=1, bty='n')
plot(thetas_9MS$I, thetas_9MS_alphaUpper$I,
     log = 'xy',
     ylab = 'Reinfection: inbred',
     xlab = 'Reinfection: no inbreeding',
     col= drug_cols2[thetas_9MS$drug],pch=20)
lines(c(-10,10),c(-10,10),lty=2)

plot(log10(thetas_9MS$I), log10(thetas_9MS$I)-log10(thetas_9MS_alphaUpper$I),
     ylab = 'Difference in Log Reinfection Probabilities',
     xlab = 'Reinfection: no inbreeding',
     col= drug_cols2[thetas_9MS$drug],pch=20)
legend('topleft', legend = c('No PMQ', 'PMQ+'), col = drug_cols2[2:3], pch = 20, bty = 'n')

abline(h=0,lty=2)
toc()
```


Interpretation: Adding the inbreeding coefficent slightly changes some of the probabilities of relapse for some primaquine treated individuals (only green dots are being shifted).

This means that inbreeding would imply that fewer of the primaquine treated episodes are relapses, implying higher efficacy of the drug.

For the non-primaquine group, it is just tempering the very low probabilities of reinfection seen for some episodes.

In conclusion, this isn't changing the results significantly and would imply a greater primaquine efficacy than reported in the paper.
