---
title: "Simulation study to test vivax genetic relatedness model"
output:
  pdf_document: default
  word_document: default
  html_document:
    df_print: paged
    keep_md: yes
---

In this scr

Most relationship graphs most relation graphs compatible with relapse contain sibling. A single parasite haploid among majority unrelated 


Reviewer's example: "a recurrence with MOI of 3, containing a clone and two unrelated strains, but with overall pairwise relatedness close to 0.5."


```{r, echo=FALSE, include=F}
knitr::opts_chunk$set(cache = TRUE, cache.comments = FALSE, 
                      echo = TRUE, include = TRUE, 
                      fig.width = 7, fig.height = 7,
                      fig.pos = 'H', 
                      dev = 'png', dpi = 300)

rm(list = ls())
load('../RData/RPackages_List.RData')
new.pkg <- pkgs[!(pkgs %in% installed.packages()[, "Package"])]
if(length(new.pkg) > 0){ # Install using .R script
  stop('Please run the script Install_and_load_required_packages.R before returning to this script. Thanks.')}else{
    sapply(pkgs, require, character.only = TRUE) # Load all packages
  }
tic()
```

```{r, echo=FALSE}
source('../Genetic_Model/iGraph_functions.R')
source('../Genetic_Model/Likelihood_function.R')
source('../Genetic_Model/Data_functions.R')
source('../Genetic_Model/test_Rn_compatible.R')
source('../Genetic_Model/post_prob_CLI.R')
source('../Genetic_Model/hap_combinations_functions.R')
source('./BuildSimData.R')
```


```{r, echo=FALSE}
# Note that the model is currently run a separate script 
SIM_DATA = F
SIM_DATA_ERROR = F
SIM_DATA_COIs3_1 = F
PLOT_RESULTS = T
```

## Simulation 1: Effective Complexity of Infection

We want to assess recurrence state inference as a function of the number of markers typed, adding extra noisy parasites into an infections with COI > 1. Outline of simulation is as follows: for each "job", 

* Simulate data for N individuals, with M markers for two episodes, the second including a clonal, sibling or stranger parasite.
* Summarise the simulated data with a series of plots. 
* Compute resulting recurrence state estimates (this is currently done in a separate file)
* Plot resulting recurrence state estimates as a function m

Note that when we previously specified a cut off for the number of heterolallelic calls (K_poly_markers < M), we were unwittingly amplifing evidence for relapse because when `M <= K_poly_markers` the noisy parasite will be a stranger in relation to the other parasites in the same infection; when `K_poly_markers approx 0.5*M` the noisy parasite will be more like a sibling of the other parasites in the same infection; when `K_poly_markers << M`, the noisy parasite will approach a clone of the other parasites in the same infection, but will be considered a sibling under the model.


```{r, echo=FALSE}
set.seed(1) # For reproducibility
N_indivs = 250
cardinalities = c(4,13) # Marker cardinalities (set to match min and mean of our panel)
Ms = seq(3,12,3) # Number of MS markers
COIs_1 = c(1,2) # COIs of primary episode (COMMENT)
COIs_2 = c(1,2) # COIs of recurrent episode
relationships = c('Sibling','Stranger','Clone') # Relationships of parasite
COI_c_max = 3 # Maximum COI we currently consider for cor

# Enumerate all combinations of COI complexity and numbers of markers
settings = expand.grid(Ms = Ms, COI_1 = COIs_1, COI_2 = COIs_2) # Enumerate all possible combinations of COIs and markers 
settings = settings[settings$COI_1+settings$COI_2<=COI_c_max,] # Remove any with cumulative COI greater than that feasible
settings = rbind(settings, expand.grid(Ms = Ms, COI_1 = 3, COI_2 = 1)) # Add settings for 3_1 example
settings$COI_pattern <- paste(settings$COI_1, settings$COI_2, sep = "_") # Store the COIs as a patter
rownames(settings) = NULL
jobs_cor = which(settings$COI_pattern != '3_1') # Indices of core simulations jobs
jobs_add = which(settings$COI_pattern == '3_1') # Indices of addn simulations jobs
```


```{r, echo=FALSE}
# First simulate data for cor jobs with cardinalities 4 and 13
if(SIM_DATA){
  for(cardinality in cardinalities){ # iterate over cardinality of markers
    for(relationship in relationships){ # iterative over simulation scenario 
      
      thetas_all = foreach(job = jobs_cor, .combine = rbind, # iterate over jobs parameter settings
                           .packages = c('dplyr','Matrix','gtools','igraph','matrixStats','doParallel')
                           
      ) %do% { # parallisation happening inside the function
        
        #####################################################
        # Simulate and save MS data
        #####################################################
        sim_output = BuildSimData(COIs = c(settings$COI_1[job],  # COI from settings
                                           settings$COI_2[job]), # COI from settings
                                  M = settings$M[job], # Number of markers from settings 
                                  N = N_indivs, # Number of individuals
                                  N_alleles = cardinality, 
                                  relatedness = relationship)
        
        # Save a copy of the simulated data
        save(sim_output, file=sprintf('SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality%s_M%s_COIs%s_%s.RData', 
                                      cardinality, settings$M[job], settings$COI_pattern[job], relationship))
      }
    }
  }
}
```

```{r, echo=FALSE}
# Second simulate erroneous data for cor jobs with cardinality 13 only
error_prob = 0.20 # Ask Mallika
error_probs = c(error_prob*0.1, # This version assumes a fixed rate for all motif sizes
                error_prob*0.4, 
                1-error_prob, 
                error_prob*0.4, 
                error_prob*0.1)
sum(error_probs) # Check sums to one

if(SIM_DATA_ERROR){
  for(relationship in relationships){ # iterative over simulation scenario 
    for(job in jobs_cor){
      
      # load data
      load(sprintf('./SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality13_M%s_COIs%s_%s.RData', 
                   settings$M[job], settings$COI_pattern[job], relationship))
      
      # Add error
      MSs = names(sim_output$FS)
      data_dim = dim(sim_output$MS_data_sim[, MSs])
      errors = sample(-2:2, size = prod(data_dim), prob = error_probs, replace = T)
      MSdata_with_error = sim_output$MS_data_sim[, MSs] + array(errors, dim = data_dim)
      sim_output$MS_data_sim[, MSs] = MSdata_with_error
      
      # save a copy of the erronenous data
      save(sim_output, file = sprintf('./SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality13_M%s_COIs%s_%s_Error.RData', 
                                      settings$M[job], settings$COI_pattern[job], relationship))
    }
  }
}
```


```{r, echo=FALSE}
# Third simulate data for add jobs with cardinality 13 only
if(SIM_DATA_COIs3_1){
  for(relationship in relationships){ # iterative over simulation scenario 
    
    thetas_all = foreach(job = jobs_add, .combine = rbind, # iterate over jobs parameter settings
                         .packages = c('dplyr','Matrix','gtools','igraph','matrixStats','doParallel')
                         
    ) %do% { # parallisation happening inside the function
      
      #####################################################
      # Simulate and save MS data
      #####################################################
      sim_output = BuildSimData(COIs = c(settings$COI_1[job],  # COI from settings
                                         settings$COI_2[job]), # COI from settings
                                M = settings$M[job], # Number of markers from settings 
                                N = N_indivs, # Number of individuals
                                N_alleles = 13, 
                                relatedness = relationship)
      
      # Save a copy of the simulated data
      save(sim_output, file=sprintf('SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality13_M%s_COIs%s_%s.RData', 
                                    settings$M[job], settings$COI_pattern[job], relationship))
    }
  }
}
```


```{r, echo = FALSE}
# Now let's summarise the well-specified simulated cor data in terms of 
# fraction evidence IBS (one number per episode pair)
# fraction heteroallic (one number per episode)
if(SIM_DATA){
  for(cardinality in cardinalities){ # iterate over cardinality of markers
    for(relationship in relationships){ # iterative over simulation scenario 
      
      
      Data_summaries = lapply(jobs_cor, function(job){
        
        load(sprintf('SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality%s_M%s_COIs%s_%s.RData', 
                     cardinality, settings$M[job], settings$COI_pattern[job], relationship))
        attach(sim_output, warn.conflicts = F)
        MSnames = paste0('MS',1:settings$M[job],sep = '') # Reconstruct microsatellite names
        
        # Summarize data in terms of fraction evidence IBS (one number per episode pair)
        # and fraction heteroallic (one number per episode)
        Data_summary = ddply(MS_data_sim, 'ID', .fun = function(x){ # separate data for each individual
          
          # Separate data by episode
          Z = dlply(x, 'Episode') 
          
          # For each intra-individual comparison, reported fraction IBS
          fraction_evidence_IBS = mean(sapply(MSnames, function(MSname){
            any(Z[[1]][,MSname] %in% Z[[2]][,MSname]) # Any overlap counts as evidence
          }))
          
          
          # For each episode (rows) and markers (cols) report if call is heteroallelic
          heteroallelic_calls = sapply(MSnames, function(MSname){
            het_per_epi_given_MS = c(length(unique(Z[[1]][,MSname])) > 1, # First episode 
                                     length(unique(Z[[2]][,MSname])) > 1) # Second episode
          })
          
          # For each episode, report fraction of heteroallelic calls
          fraction_heteroallelic = rowMeans(heteroallelic_calls)
          names(fraction_heteroallelic) = c('frac_het_epi1', 'frac_het_epi2')
          
          # For each individual, reported fraction evidence IBS and het calls per episode
          c(frac_evi_IBS = fraction_evidence_IBS, fraction_heteroallelic)
        }) 
      })
      save(Data_summaries, file=sprintf('SimulationOutputs/Sim_Genetic_Data/MS_summary_Cardinality%s_%s.RData', 
                                        cardinality, relationship))
    }
  }
}
```


```{r fraction_IBS, fig.height = 5, fig.width = 12, echo = FALSE}
#=============================================================
# Visualize summarised data fraction IBS for sib and stranger
# (evidence of IBS is always one for clone)
#=============================================================
par(mfrow = c(2,6))
for(relationship in c("Sibling", "Stranger")){ 
  
  for(cardinality in cardinalities){
    
    load(sprintf('SimulationOutputs/Sim_Genetic_Data/MS_summary_Cardinality%s_%s.RData', cardinality, relationship))
    
    # Distribution of IBS (for a given relationship, cardinality, COI pattern, they should be approximately the same)
    fracs_evi_IBS = sapply(Data_summaries, function(x){x$frac_evi_IBS})
    colnames(fracs_evi_IBS) = apply(settings[jobs_cor,], 1, function(x) paste(as.numeric(x[1]), x[2], x[3], collapse = ''))
    require(RColorBrewer)
    cols = sapply(brewer.pal(length(Ms), 'GnBu'), adjustcolor, alpha.f = 1) # Adjust col if hist
    names(cols)= Ms
    
    cs = c(0,0) 
    for(j in 1:ncol(fracs_evi_IBS)){
      pars = unlist(strsplit(colnames(fracs_evi_IBS)[j], split = ' '))
      if(all(pars[2:3] == cs)){ADD = T}else{ADD = F} 
      
      # As histogram: a bit messy
      # hist(fracs_evi_IBS[,j], xlim = c(0,1), col = cols[pars[1]], las = 1, add = ADD, breaks = 20, 
      #      main = bquote(italic(c)^(1)==.(pars[2])~"  "~italic(c)^(2)==.(pars[3])), 
      #      xlab = 'Fraction of evidence of IBS',
      #      ylab = 'Number of epsisode pairs')
      
      # As density
      if(!all(pars[2:3] == cs)){ 
        dens = density(fracs_evi_IBS[,j])
        plot(dens, xlim = c(0,1), type = 'l', ylim = c(0,2*max(dens$y)), bty = 'n', 
             col = cols[pars[1]], xlab = 'Fraction with IBS evidence', las = 1, 
             main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
      } else {
        lines(density(fracs_evi_IBS[,j]), col = cols[pars[1]])
      }
      
      abline(v = mean(fracs_evi_IBS[,j]), col = cols[pars[1]])
      legend('topleft', lty = 1, col = cols, legend = names(cols), 
             inset = 0.025, cex = 0.5, title = expression(italic(m)))
      cs = pars[2:3]
    }
  }
}
```


```{r fraction_het_epi1, fig.height = 8, fig.width = 12, echo = F, include = F}
#=====================================================================
# Visualize summarised data fraction het episode 1 
#=====================================================================
par(mfrow = c(3,6))
for(relationship in c("Sibling", "Stranger","Clone")){
  
  for(cardinality in cardinalities){
    
    load(sprintf('SimulationOutputs/Sim_Genetic_Data/MS_summary_Cardinality%s_%s.RData', cardinality, relationship))
    
    # Distribution of IBS (for a given relationship, cardinality, COI pattern, they should be approximately the same)
    fracs_het_epi1 = sapply(Data_summaries, function(x){x$frac_het_epi1})
    colnames(fracs_het_epi1) = apply(settings[jobs_cor,], 1, function(x) paste(as.numeric(x[1]), x[2], x[3], collapse = ''))
    require(RColorBrewer)
    cols = sapply(brewer.pal(length(Ms), 'GnBu'), adjustcolor, alpha.f = 1) # Adjust col if hist
    names(cols)= Ms
    
    cs = c(0,0) 
    for(j in 1:ncol(fracs_het_epi1)){
      pars = unlist(strsplit(colnames(fracs_het_epi1)[j], split = ' '))
      if(all(pars[2:3] == cs)){ADD = T}else{ADD = F} 
      
      # As density
      if(!all(pars[2:3] == cs)){ 
        if(diff(range(fracs_het_epi1[,j])) == 0){
          plot(NULL, xlim = c(0,1), ylim = c(0,2*max(dens$y)), bty = 'n', 
               xlab = 'Fraction het. episode 1', las = 1, 
               main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
          abline(v = mean(fracs_het_epi1[,j]))
        } else {
          dens = density(fracs_het_epi1[,j])
          plot(dens, xlim = c(0,1), type = 'l', ylim = c(0,2*max(dens$y)), bty = 'n', 
               col = cols[pars[1]], xlab = 'Fraction het. episode 1', las = 1, 
               main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
        }
        
      } else {
        if(diff(range(fracs_het_epi1[,j])) == 0){next()
        } else {
          lines(density(fracs_het_epi1[,j]), col = cols[pars[1]])   
        }
      }
      
      abline(v = mean(fracs_het_epi1[,j]), col = cols[pars[1]])
      legend('topleft', lty = 1, col = cols, legend = names(cols), inset = 0.025, cex = 0.5)
      cs = pars[2:3]
    }
  }
}
```

```{r fraction_het_epi2, fig.height = 8, fig.width = 12, echo = F, include = F}
#=====================================================================
# Visualize summarised data fraction het epsisode 2 
#=====================================================================
par(mfrow = c(3,6))
for(relationship in c("Sibling", "Stranger", "Clone")){ 
  for(cardinality in cardinalities){
    
    load(sprintf('SimulationOutputs/Sim_Genetic_Data/MS_summary_Cardinality%s_%s.RData', cardinality, relationship))
    
    # Distribution of IBS (for a given relationship, cardinality, COI pattern, they should be approximately the same)
    fracs_het_epi2 = sapply(Data_summaries, function(x){x$frac_het_epi2})
    colnames(fracs_het_epi2) = apply(settings[jobs_cor,], 1, function(x) paste(as.numeric(x[1]), x[2], x[3], collapse = ''))
    require(RColorBrewer)
    cols = sapply(brewer.pal(length(Ms), 'GnBu'), adjustcolor, alpha.f = 1) # Adjust col if hist
    names(cols)= Ms
    
    cs = c(0,0) 
    for(j in 1:ncol(fracs_het_epi2)){
      pars = unlist(strsplit(colnames(fracs_het_epi2)[j], split = ' '))
      if(all(pars[2:3] == cs)){ADD = T}else{ADD = F} 
      
      # As density
      if(!all(pars[2:3] == cs)){ 
        
        if(diff(range(fracs_het_epi2[,j])) == 0){
          plot(NULL, xlim = c(0,1), ylim = c(0,2*max(dens$y)), bty = 'n', 
               xlab = 'Fraction het. episode 2', las = 1, 
               main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
          abline(v = mean(fracs_het_epi2[,j]), col = 'black')
        } else {
          dens = density(fracs_het_epi2[,j])
          plot(dens, xlim = c(0,1), type = 'l', ylim = c(0,2*max(dens$y)), bty = 'n', 
               col = cols[pars[1]], xlab = 'Fraction het. episode 2', las = 1, 
               main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
        }
        
      } else {
        if(diff(range(fracs_het_epi2[,j])) == 0){next()
        } else {
          lines(density(fracs_het_epi2[,j]), col = cols[pars[1]])   
        }}
      
      
      abline(v = mean(fracs_het_epi2[,j]), col = cols[pars[1]])
      legend('topleft', lty = 1, col = cols, legend = names(cols), inset = 0.025, cex = 0.5)
      cs = pars[2:3]
    }
  }
}
```




\section{Results}

```{r results_COI_effect, fig.width = 12, fig.height = 5, echo = F}
States = c("C","I","L")
State_names = list(L='Relapse',I='Reinfection',C='Recrudescence')
if(PLOT_RESULTS){
  
  mycols = brewer.pal(length(State_names), 'Dark2')
  relationship_names = c('Clone' = 'Clonal scenario', 
                         'Sibling' = 'Sibling scenario',
                         'Stranger' = 'Stranger scenario')
  
  par(mfrow = c(1,3), family = 'serif', pty = 's', oma = c(0,0,3,0), las =1, mar=c(4,5,4,1))
  BESIDES = T # Allows visualisation of error by stacking bars side by side
  
  for(cardinality in cardinalities){ # cardinalities
    
    for(pattern in unique(settings[jobs_cor,]$COI_pattern)){
      
      JOBS_pattern <- which(settings$COI_pattern == as.character(pattern))
      
      for(relationship in relationships){ # Iterate over simulation scenarions (types of data)
        
        # Load data 
        load(sprintf('./SimulationOutputs/Sim_Genetic_Results/%s_%s.RData',relationship, cardinality))
        
        # Extract medians
        X <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, median, na.rm = T)
        })
        
        # Extract standard deviations
        sds <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, sd, na.rm = T)
        })
        
        colnames(X) = settings[JOBS_pattern,'M']
        
        # Barplot
        Z = barplot(X, beside = BESIDES, col = mycols[1:3], ylim = c(0,1), 
                    ylab = '', xlab = '', cex.names=1.5,cex.axis = 1.5,
                    main = relationship_names[relationship])
        mtext(text = 'Probability', side = 2, line=3.5, cex=1, las=3)
        mtext(text = 'Number of markers', side = 1, line=3, cex=1.3)
        if(relationship=='Clone'){
          legend(ifelse(BESIDES,'topleft','top'), fill = mycols[1:3], 
                 legend = State_names[States], inset = 0.01,cex = 1.3)
        }
        
        # Title
        mtext(text = sprintf('Marker cardinality: %s \n COI of first and second infection: %s and %s, respectively', 
                             cardinality, 
                             strsplit(pattern, split = '_')[[1]][1], 
                             strsplit(pattern, split = '_')[[1]][2]), side = 3, outer = T)
        
        # Add error bars (+/- sd)
        if(BESIDES){
          rownames(Z) <- States
          for(state in States){
            segments(x0 = Z[state,], x1 = Z[state,], 
                     y0 = X[state,] - sds[state,], y1 = X[state,] + sds[state,])
          }
        }
      }
    }
  }
}
toc()
```


```{r GenSim_Error, fig.width = 12, fig.height = 5, echo = F, fig.cap='\\label{fig: error}The probability of recurrent states as a function of the number of markers typed in a sibling, stranger and clonal scenario assuming an extremely high probability of error.'}
States = c("C","I","L")
State_names = list(L='Relapse',I='Reinfection',C='Recrudescence')
if(PLOT_RESULTS){
  
  mycols = brewer.pal(length(State_names), 'Dark2')
  relationship_names = c('Clone' = 'Clonal scenario', 
                         'Sibling' = 'Sibling scenario',
                         'Stranger' = 'Stranger scenario')
  
  par(mfrow = c(1,3), family = 'serif', pty = 's', oma = c(0,0,3,0), las =1, mar=c(4,5,4,1))
  BESIDES = T # Allows visualisation of error by stacking bars side by side

    for(pattern in unique(settings[jobs_cor,]$COI_pattern)){
      
      JOBS_pattern <- which(settings$COI_pattern == as.character(pattern))
      
      for(relationship in relationships){ # Iterate over simulation scenarions (types of data)
        
        # Load data 
        load(sprintf('./SimulationOutputs/Sim_Genetic_Results/%s_13_Error.RData',relationship))
        
        # Extract medians
        X <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, median, na.rm = T)
        })
        
        # Extract standard deviations
        sds <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, sd, na.rm = T)
        })
        
        colnames(X) = settings[JOBS_pattern,'M']
        
        # Barplot
        Z = barplot(X, beside = BESIDES, col = mycols[1:3], ylim = c(0,1), 
                    ylab = '', xlab = '', cex.names=1.5,cex.axis = 1.5,
                    main = relationship_names[relationship])
        mtext(text = 'Probability', side = 2, line=3.5, cex=1, las=3)
        mtext(text = 'Number of markers', side = 1, line=3, cex=1.3)
        if(relationship=='Clone'){
          legend(ifelse(BESIDES,'topleft','top'), fill = mycols[1:3], 
                 legend = State_names[States], inset = 0.01,cex = 1.3)
        }
        
        # Title
        mtext(text = sprintf('Marker cardinality: %s \n COI of first and second infection: %s and %s, respectively', 
                             cardinality, 
                             strsplit(pattern, split = '_')[[1]][1], 
                             strsplit(pattern, split = '_')[[1]][2]), side = 3, outer = T)
        
        # Add error bars (+/- sd)
        if(BESIDES){
          rownames(Z) <- States
          for(state in States){
            segments(x0 = Z[state,], x1 = Z[state,], 
                     y0 = X[state,] - sds[state,], y1 = X[state,] + sds[state,])
          }
        }
      }
    }
  }
toc()
```


```{r GenSim_COI31, fig.width = 12, fig.height = 5, echo = F, fig.cap='\\label{fig: COI31}The probability of recurrent states as a function of the number of markers typed in a sibling, stranger and clonal scenario when the COI of the initial infection is three and the COI of the recurrent infection is one.'}
States = c("C","I","L")
State_names = list(L='Relapse',I='Reinfection',C='Recrudescence')
if(PLOT_RESULTS){
  
  mycols = brewer.pal(length(State_names), 'Dark2')
  relationship_names = c('Clone' = 'Clonal scenario', 
                         'Sibling' = 'Sibling scenario',
                         'Stranger' = 'Stranger scenario')
  
  par(mfrow = c(1,3), family = 'serif', pty = 's', oma = c(0,0,3,0), las =1, mar=c(4,5,4,1))
  BESIDES = T # Allows visualisation of error by stacking bars side by side

    for(pattern in unique(settings[jobs_add,]$COI_pattern)){
      
      JOBS_pattern <- which(settings$COI_pattern == as.character(pattern))
      
      for(relationship in relationships){ # Iterate over simulation scenarions (types of data)
        
        # Load data 
        load(sprintf('./SimulationOutputs/Sim_Genetic_Results/%s_13_COIs3_1.RData',relationship))
        
        # Extract medians
        X <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, median, na.rm = T)
        })
        
        # Extract standard deviations
        sds <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, sd, na.rm = T)
        })
        
        colnames(X) = settings[JOBS_pattern,'M']
        
        # Barplot
        Z = barplot(X, beside = BESIDES, col = mycols[1:3], ylim = c(0,1), 
                    ylab = '', xlab = '', cex.names=1.5,cex.axis = 1.5,
                    main = relationship_names[relationship])
        mtext(text = 'Probability', side = 2, line=3.5, cex=1, las=3)
        mtext(text = 'Number of markers', side = 1, line=3, cex=1.3)
        if(relationship=='Clone'){
          legend(ifelse(BESIDES,'topleft','top'), fill = mycols[1:3], 
                 legend = State_names[States], inset = 0.01,cex = 1.3)
        }
        
        # Title
        mtext(text = sprintf('Marker cardinality: %s \n COI of first and second infection: %s and %s, respectively', 
                             cardinality, 
                             strsplit(pattern, split = '_')[[1]][1], 
                             strsplit(pattern, split = '_')[[1]][2]), side = 3, outer = T)
        
        # Add error bars (+/- sd)
        if(BESIDES){
          rownames(Z) <- States
          for(state in States){
            segments(x0 = Z[state,], x1 = Z[state,], 
                     y0 = X[state,] - sds[state,], y1 = X[state,] + sds[state,])
          }
        }
      }
    }
  }
toc()
```

The genetic model relies on data that list alleles detected at genotyped microsatellite markers (i.e. alleles are either detected or not). The model does not account for error in the alleles detected, nor incorporate weighted evidence of majority versus minority alleles, say. First, let's consider the failure to detect minority clones, second let's consider the impact of error. 

\subsubsection{Undetected parasite haploid genotypes}

Failure to detect data from a minority parasite haploid genotype will have different consequences, depending on the relationship of the minority parasite with others across episodes. For example, referring to each plot in Figure XXX as an illustrative scenario where COI I II denotes a COI of I in the first infection and a COI of II in the second infection, 

- in the Sibling COI 2 1 case, failure to detect the stranger parasite will result in the Sibling COI 1 1 case, thereby increasing probability relapsing; meanwhile, failure to detect the sibling parasite will result in the Stranger COI 1 1 case, thereby decreasing probability of relpase, but not erasing it. Note that the case in which the noisy parasite is unrelated demonstrates the most severe possible outcome: if the noisy parasite were related, failure to detect it would result in a Sibling COI 1 1 case, thereby maintaining probability of relapse.  

- failure to detect either stranger parasite in the Clone COI 2 1 case will result in the Stranger COI 1 1 case, maintaining probability of reinfection and relapse. 

- In the Clone COI 2 1 case, failure to detect the stranger parasite will result in the Clone COI 1 1 case, thereby maintaining probability of recrudescence and relapse; meanwhile, failure to detect the clonal parasite will result in the Stranger COI 1 1 case, thereby erasing probability of recrudescence and replacing it with probability of reinfection.

The examples above illustrate the robust versus frail nature of relapse versus recrudescene inference under the model. Relapse infernce is also robust in the prescence of error, whereas recrudescence is not. 

\subsubsection{Erroneous data}

Figure XXX shows inference in the presence of unmodelled error. The probability of error, 0.2, was set extremely high to clearly illustrate model behaviour. Realistic error rates, XXX-XXX, will have much less impact. Error largely impacts impacts inference of recrudescence: in the Clonal scenario clonal parasites are interpreted as sibling parasites and the probability of relapse tends towards one.


\subsection{Highly complex data}

A major limitation of the genetic model has to do with computational complexity. One aspect of which is described below. When samples are highly complex, e.g. when they contain majority unrelated parasites, unconverged probablistic phasing is liable to miss clonally compatible combinations among the vast number of combinations that are possible. The number of possible combinations grows exponentially with the number of markers genotyped, rendering probability estimates inconsistent for recrudescence (Figure \ref{fig: COI3_1}). Such highly complex scenarios are extreme. They are helpful for illustrating the problem (Figure \ref{fig: COI3_1}), but not representative of the VHX and BPD data: all those analysed probablistic phasing converged. Otherwise stated, inconsistency is not a problem VHX and BPD data anlysed under the model. 

Nine individuals from the VHX and BPD datasets were deemed to have data too complex to analyse under the model. They received drugs XXX. All nine individuls appear to have had multoiple relapses, based on data vizualisation, which can be used to rapidly identify clonally compatible phases, where computational methods fail (Figure XXX).


\section{Conclusion}
The current genetic model does not account for error in alleles detected, nor incorporate weighted evidence of majority versus minority alleles. These omissions render inference of recrudescence under the current model brittle, but have little impact on inference of reinfection versus relapse. As such, analyses of data from the Thailand_Myanmar border, where evidence of resistant \textit{P. vivax} is lacking, are likely robust to the above ommissions. Before application to data from a region where \textit{P. vivax} resistance is suspected, the model merits extension. 


