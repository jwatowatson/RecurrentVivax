---
title: "Simulation study to test vivax genetic relatedness model"
output:
  pdf_document: default
  word_document: default
  html_document:
    df_print: paged
    keep_md: yes
---

Reviewer's example: "a recurrence with MOI of 3, containing a clone and two unrelated strains, but with overall pairwise relatedness close to 0.5."


```{r, echo=FALSE, include=F}
knitr::opts_chunk$set(cache = TRUE, cache.comments = FALSE, 
                      echo = TRUE, include = TRUE, 
                      fig.width = 7, fig.height = 7,
                      fig.pos = 'H', 
                      dev = 'png', dpi = 300)

rm(list = ls())
load('../RData/RPackages_List.RData')
new.pkg <- pkgs[!(pkgs %in% installed.packages()[, "Package"])]
if(length(new.pkg) > 0){ # Install using .R script
  stop('Please run the script Install_and_load_required_packages.R before returning to this script. Thanks.')}else{
    sapply(pkgs, require, character.only = TRUE) # Load all packages
  }
tic()
```

```{r, echo=FALSE}
source('../Genetic_Model/iGraph_functions.R')
source('../Genetic_Model/Likelihood_function.R')
source('../Genetic_Model/Data_functions.R')
source('../Genetic_Model/test_Rn_compatible.R')
source('../Genetic_Model/post_prob_CLI.R')
source('../Genetic_Model/hap_combinations.R')
source('./BuildSimData.R')
```


```{r, echo=FALSE}
# Note that the model is currently run a separate script 
SIM_DATA = T
SIM_DATA_ERROR = T
SIM_DATA_COIs2_1 = T
PLOT_RESULTS = T
```

## Simulation 1: Effective Complexity of Infection

We want to assess recurrence state inference as a function of the number of markers typed, adding extra noisy parasites into an infections with COI > 1. Outline of simulation is as follows: for each "job", 

* Simulate data for N individuals, with M markers for two episodes, the second including a clonal, sibling or stranger parasite.
* Summarise the simulated data with a series of plots. 
* Compute resulting recurrence state estimates (this is currently done in a separate file)
* Plot resulting recurrence state estimates as a function m

Note that when we previously specified a cut off for the number of heterolallelic calls (K_poly_markers < M), we were unwittingly amplifing evidence for relapse because when `M <= K_poly_markers` the noisy parasite will be a stranger in relation to the other parasites in the same infection; when `K_poly_markers approx 0.5*M` the noisy parasite will be more like a sibling of the other parasites in the same infection; when `K_poly_markers << M`, the noisy parasite will approach a clone of the other parasites in the same infection, but will be considered a sibling under the model.


```{r, echo=FALSE}
set.seed(1) # For reproducibility
N_indivs = 250
cardinalities = c(4,13) # Marker cardinalities (set to match min and mean of our panel)
Ms = seq(3,12,3) # Number of MS markers
COIs_1 = c(1,3) # COIs of primary episode (COMMENT)
COIs_2 = c(1,3) # COIs of recurrent episode
relationships = c('Sibling','Stranger','Clone') # Relationships of parasite
COI_c_max = 4 # Maximum COI we currently consider

# Enumerate all combinations of COI complexity and numbers of markers
settings = expand.grid(Ms = Ms, COI_1 = COIs_1, COI_2 = COIs_2) # Enumerate all possible combinations of COIs and markers 
settings = rbind(settings, expand.grid(Ms = Ms, COI_1 = 2, COI_2 = 1)) # Add settings for 2_1
settings = settings[settings$COI_1+settings$COI_2<=COI_c_max,] # Remove any with cumulative COI greater than that feasible
settings$COI_pattern <- paste(settings$COI_1, settings$COI_2, sep = "_") # Store the COIs as a patter
rownames(settings) = NULL
jobs_cor = which(settings$COI_pattern != '2_1') # Indices of core simulations jobs
jobs_add = which(settings$COI_pattern == '2_1') # Indices of addn simulations jobs
```


```{r, echo=FALSE}
# First simulate data for cor jobs with cardinalities 4 and 13
if(SIM_DATA){
  for(cardinality in cardinalities){ # iterate over cardinality of markers
    for(relationship in relationships){ # iterative over simulation scenario 
      
      thetas_all = foreach(job = jobs_cor, .combine = rbind, # iterate over jobs parameter settings
                           .packages = c('dplyr','Matrix','gtools','igraph','matrixStats','doParallel')
                           
      ) %do% { # parallisation happening inside the function
        
        #####################################################
        # Simulate and save MS data
        #####################################################
        sim_output = BuildSimData(COIs = c(settings$COI_1[job],  # COI from settings
                                           settings$COI_2[job]), # COI from settings
                                  M = settings$M[job], # Number of markers from settings 
                                  N = N_indivs, # Number of individuals
                                  N_alleles = cardinality, 
                                  relatedness = relationship)
        
        # Save a copy of the simulated data
        save(sim_output, file=sprintf('SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality%s_M%s_COIs%s_%s.RData', 
                                      cardinality, settings$M[job], settings$COI_pattern[job], relationship))
      }
    }
  }
}
```

```{r, echo=FALSE}
# Second simulate erroneous data for cor jobs with cardinality 13 only
error_prob = 0.25 # Ask Mallika
error_probs = c(error_prob*0.1, # This version assumes a fixed rate for all motif sizes
                error_prob*0.4, 
                1-error_prob, 
                error_prob*0.4, 
                error_prob*0.1)
sum(error_probs) # Check sums to one

if(SIM_DATA_ERROR){
  for(relationship in relationships){ # iterative over simulation scenario 
    for(job in jobs_cor){
      
      # load data
      load(sprintf('./SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality13_M%s_COIs%s_%s.RData', 
                   settings$M[job], settings$COI_pattern[job], relationship))
      
      # Add error
      MSs = names(sim_output$FS)
      data_dim = dim(sim_output$MS_data_sim[, MSs])
      errors = sample(-2:2, size = prod(data_dim), prob = error_probs, replace = T)
      MSdata_with_error = sim_output$MS_data_sim[, MSs] + array(errors, dim = data_dim)
      sim_output$MS_data_sim[, MSs] = MSdata_with_error
      
      # save a copy of the erronenous data
      save(sim_output, file = sprintf('./SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality13_M%s_COIs%s_%s_Error.RData', 
                                      settings$M[job], settings$COI_pattern[job], relationship))
    }
  }
}
```


```{r, echo=FALSE}
# Third simulate data for add jobs with cardinality 13 only
if(SIM_DATA_COIs2_1){
  for(relationship in relationships){ # iterative over simulation scenario 
    
    thetas_all = foreach(job = jobs_add, .combine = rbind, # iterate over jobs parameter settings
                         .packages = c('dplyr','Matrix','gtools','igraph','matrixStats','doParallel')
                         
    ) %do% { # parallisation happening inside the function
      
      #####################################################
      # Simulate and save MS data
      #####################################################
      sim_output = BuildSimData(COIs = c(settings$COI_1[job],  # COI from settings
                                         settings$COI_2[job]), # COI from settings
                                M = settings$M[job], # Number of markers from settings 
                                N = N_indivs, # Number of individuals
                                N_alleles = 13, 
                                relatedness = relationship)
      
      # Save a copy of the simulated data
      save(sim_output, file=sprintf('SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality13_M%s_COIs%s_%s.RData', 
                                    settings$M[job], settings$COI_pattern[job], relationship))
    }
  }
}
```


```{r, echo = FALSE}
# Now let's summarise the well-specified simulated cor data in terms of 
# fraction evidence IBS (one number per episode pair)
# fraction heteroallic (one number per episode)
if(SIM_DATA){
  for(cardinality in cardinalities){ # iterate over cardinality of markers
    for(relationship in relationships){ # iterative over simulation scenario 
      
      
      Data_summaries = lapply(jobs_cor, function(job){
        
        load(sprintf('SimulationOutputs/Sim_Genetic_Data/MS_Data_Cardinality%s_M%s_COIs%s_%s.RData', 
                     cardinality, settings$M[job], settings$COI_pattern[job], relationship))
        attach(sim_output, warn.conflicts = F)
        MSnames = paste0('MS',1:settings$M[job],sep = '') # Reconstruct microsatellite names
        
        # Summarize data in terms of fraction evidence IBS (one number per episode pair)
        # and fraction heteroallic (one number per episode)
        Data_summary = ddply(MS_data_sim, 'ID', .fun = function(x){ # separate data for each individual
          
          # Separate data by episode
          Z = dlply(x, 'Episode') 
          
          # For each intra-individual comparison, reported fraction IBS
          fraction_evidence_IBS = mean(sapply(MSnames, function(MSname){
            any(Z[[1]][,MSname] %in% Z[[2]][,MSname]) # Any overlap counts as evidence
          }))
          
          
          # For each episode (rows) and markers (cols) report if call is heteroallelic
          heteroallelic_calls = sapply(MSnames, function(MSname){
            het_per_epi_given_MS = c(length(unique(Z[[1]][,MSname])) > 1, # First episode 
                                     length(unique(Z[[2]][,MSname])) > 1) # Second episode
          })
          
          # For each episode, report fraction of heteroallelic calls
          fraction_heteroallelic = rowMeans(heteroallelic_calls)
          names(fraction_heteroallelic) = c('frac_het_epi1', 'frac_het_epi2')
          
          # For each individual, reported fraction evidence IBS and het calls per episode
          c(frac_evi_IBS = fraction_evidence_IBS, fraction_heteroallelic)
        }) 
      })
      save(Data_summaries, file=sprintf('SimulationOutputs/Sim_Genetic_Data/MS_summary_Cardinality%s_%s.RData', 
                                        cardinality, relationship))
    }
  }
}
```


```{r fraction_IBS, fig.height = 5, fig.width = 12, echo = FALSE}
#=============================================================
# Visualize summarised data fraction IBS for sib and stranger
# (evidence of IBS is always one for clone)
#=============================================================
par(mfrow = c(2,6))
for(relationship in c("Sibling", "Stranger")){ 
  
  for(cardinality in cardinalities){
    
    load(sprintf('SimulationOutputs/Sim_Genetic_Data/MS_summary_Cardinality%s_%s.RData', cardinality, relationship))
    
    # Distribution of IBS (for a given relationship, cardinality, COI pattern, they should be approximately the same)
    fracs_evi_IBS = sapply(Data_summaries, function(x){x$frac_evi_IBS})
    colnames(fracs_evi_IBS) = apply(settings, 1, function(x) paste(as.numeric(x[1]), x[2], x[3], collapse = ''))
    require(RColorBrewer)
    cols = sapply(brewer.pal(length(Ms), 'GnBu'), adjustcolor, alpha.f = 1) # Adjust col if hist
    names(cols)= Ms
    
    cs = c(0,0) 
    for(j in 1:ncol(fracs_evi_IBS)){
      pars = unlist(strsplit(colnames(fracs_evi_IBS)[j], split = ' '))
      if(all(pars[2:3] == cs)){ADD = T}else{ADD = F} 
      
      # As histogram: a bit messy
      # hist(fracs_evi_IBS[,j], xlim = c(0,1), col = cols[pars[1]], las = 1, add = ADD, breaks = 20, 
      #      main = bquote(italic(c)^(1)==.(pars[2])~"  "~italic(c)^(2)==.(pars[3])), 
      #      xlab = 'Fraction of evidence of IBS',
      #      ylab = 'Number of epsisode pairs')
      
      # As density
      if(!all(pars[2:3] == cs)){ 
        dens = density(fracs_evi_IBS[,j])
        plot(dens, xlim = c(0,1), type = 'l', ylim = c(0,2*max(dens$y)), bty = 'n', 
             col = cols[pars[1]], xlab = 'Fraction with IBS evidence', las = 1, 
             main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
      } else {
        lines(density(fracs_evi_IBS[,j]), col = cols[pars[1]])
      }
      
      abline(v = mean(fracs_evi_IBS[,j]), col = cols[pars[1]])
      legend('topleft', lty = 1, col = cols, legend = names(cols), 
             inset = 0.025, cex = 0.5, title = expression(italic(m)))
      cs = pars[2:3]
    }
  }
}
```


```{r fraction_het_epi1, fig.height = 8, fig.width = 12, echo = F}
#=====================================================================
# Visualize summarised data fraction het episode 1 
#=====================================================================
par(mfrow = c(3,6))
for(relationship in c("Sibling", "Stranger","Clone")){
  
  for(cardinality in cardinalities){
    
    load(sprintf('SimulationOutputs/Sim_Genetic_Data/MS_summary_Cardinality%s_%s.RData', cardinality, relationship))
    
    # Distribution of IBS (for a given relationship, cardinality, COI pattern, they should be approximately the same)
    fracs_het_epi1 = sapply(Data_summaries, function(x){x$frac_het_epi1})
    colnames(fracs_het_epi1) = apply(settings, 1, function(x) paste(as.numeric(x[1]), x[2], x[3], collapse = ''))
    require(RColorBrewer)
    cols = sapply(brewer.pal(length(Ms), 'GnBu'), adjustcolor, alpha.f = 1) # Adjust col if hist
    names(cols)= Ms
    
    cs = c(0,0) 
    for(j in 1:ncol(fracs_het_epi1)){
      pars = unlist(strsplit(colnames(fracs_het_epi1)[j], split = ' '))
      if(all(pars[2:3] == cs)){ADD = T}else{ADD = F} 
      
      # As density
      if(!all(pars[2:3] == cs)){ 
        if(diff(range(fracs_het_epi1[,j])) == 0){
          plot(NULL, xlim = c(0,1), ylim = c(0,2*max(dens$y)), bty = 'n', 
               xlab = 'Fraction het. episode 1', las = 1, 
               main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
          abline(v = mean(fracs_het_epi1[,j]))
        } else {
          dens = density(fracs_het_epi1[,j])
          plot(dens, xlim = c(0,1), type = 'l', ylim = c(0,2*max(dens$y)), bty = 'n', 
               col = cols[pars[1]], xlab = 'Fraction het. episode 1', las = 1, 
               main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
        }
        
      } else {
        if(diff(range(fracs_het_epi1[,j])) == 0){next()
        } else {
          lines(density(fracs_het_epi1[,j]), col = cols[pars[1]])   
        }
      }
      
      abline(v = mean(fracs_het_epi1[,j]), col = cols[pars[1]])
      legend('topleft', lty = 1, col = cols, legend = names(cols), inset = 0.025, cex = 0.5)
      cs = pars[2:3]
    }
  }
}
```

```{r fraction_het_epi2, fig.height = 8, fig.width = 12, echo = F}
#=====================================================================
# Visualize summarised data fraction het epsisode 2 
#=====================================================================
par(mfrow = c(3,6))
for(relationship in c("Sibling", "Stranger", "Clone")){ 
  for(cardinality in cardinalities){
    
    load(sprintf('SimulationOutputs/Sim_Genetic_Data/MS_summary_Cardinality%s_%s.RData', cardinality, relationship))
    
    # Distribution of IBS (for a given relationship, cardinality, COI pattern, they should be approximately the same)
    fracs_het_epi2 = sapply(Data_summaries, function(x){x$frac_het_epi2})
    colnames(fracs_het_epi2) = apply(settings, 1, function(x) paste(as.numeric(x[1]), x[2], x[3], collapse = ''))
    require(RColorBrewer)
    cols = sapply(brewer.pal(length(Ms), 'GnBu'), adjustcolor, alpha.f = 1) # Adjust col if hist
    names(cols)= Ms
    
    cs = c(0,0) 
    for(j in 1:ncol(fracs_het_epi2)){
      pars = unlist(strsplit(colnames(fracs_het_epi2)[j], split = ' '))
      if(all(pars[2:3] == cs)){ADD = T}else{ADD = F} 
      
      # As density
      if(!all(pars[2:3] == cs)){ 
        
        if(diff(range(fracs_het_epi2[,j])) == 0){
          plot(NULL, xlim = c(0,1), ylim = c(0,2*max(dens$y)), bty = 'n', 
               xlab = 'Fraction het. episode 2', las = 1, 
               main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
          abline(v = mean(fracs_het_epi2[,j]), col = 'black')
        } else {
          dens = density(fracs_het_epi2[,j])
          plot(dens, xlim = c(0,1), type = 'l', ylim = c(0,2*max(dens$y)), bty = 'n', 
               col = cols[pars[1]], xlab = 'Fraction het. episode 2', las = 1, 
               main = bquote(italic(c)^(1)==.(pars[2])~" "~italic(c)^(2)==.(pars[3])))
        }
        
      } else {
        if(diff(range(fracs_het_epi2[,j])) == 0){next()
        } else {
          lines(density(fracs_het_epi2[,j]), col = cols[pars[1]])   
        }}
      
      
      abline(v = mean(fracs_het_epi2[,j]), col = cols[pars[1]])
      legend('topleft', lty = 1, col = cols, legend = names(cols), inset = 0.025, cex = 0.5)
      cs = pars[2:3]
    }
  }
}
```




### Plot results

```{r results_COI_effect, fig.width = 12, fig.height = 5, echo = F}
States = c("C","I","L")
if(PLOT_RESULTS){
  
  # Alternative vizualisation: show one row in main plot
  State_names = list(L='Relapse',I='Reinfection',C='Recrudescence')
  mycols = brewer.pal(length(State_names), 'Dark2')
  relationship_names = c('Clone' = 'Clonal scenario', 
                         'Sibling' = 'Sibling scenario',
                         'Stranger' = 'Stranger scenario')
  
  par(mfrow = c(1,3), family = 'serif', pty = 's', oma = c(0,0,3,0), las =1, mar=c(4,5,4,1))
  BESIDES = T # Allows visualisation of error by stacking bars side by side
  
  for(cardinality in cardinalities){ # cardinalities
    
    for(pattern in unique(settings$COI_pattern)){
      JOBS_pattern <- which(settings$COI_pattern == as.character(pattern))
      
      
      # Iterate over simulation scenarions (types of data)
      for(relationship in relationships){
        
        # Load data 
        load(sprintf('./SimulationOutputs/Sim_Genetic_Results/%s_%s.RData',
                     relationship, cardinality))
        
        # Extract medians
        X <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, median)
        })
        
        #++++++++++++
        ind <- thetas_all$setting %in% JOBS_pattern[-(1:2)]
        thetas_all[ind,]
        
        # Extract standard deviations
        sds <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, sd)
        })
        
        colnames(X) = settings[JOBS_pattern,'M']
        
        # Barplot
        Z = barplot(X, beside = BESIDES, col = mycols[1:3], ylim = c(0,1), 
                    ylab = '', xlab = '', cex.names=1.5,cex.axis = 1.5,
                    main = relationship_names[relationship])
        mtext(text = 'Probability', side = 2, line=3.5, cex=1, las=3)
        mtext(text = 'Number of markers', side = 1, line=3, cex=1.3)
        if(relationship=='Clone'){
          legend(ifelse(BESIDES,'topleft','top'), fill = mycols[1:3], 
                 legend = State_names[States], inset = 0.01,cex = 1.3)
        }
        
        # Title
        mtext(text = sprintf('Marker cardinality: %s \n COI of first and second infection: %s and %s, respectively', 
                             cardinality, 
                             strsplit(pattern, split = '_')[[1]][1], 
                             strsplit(pattern, split = '_')[[1]][2]), side = 3, outer = T)
        
        # Add error bars (+/- sd)
        if(BESIDES){
          rownames(Z) <- States
          for(state in States){
            segments(x0 = Z[state,], x1 = Z[state,], 
                     y0 = X[state,] - sds[state,], y1 = X[state,] + sds[state,])
          }
        }
      }
    }
  }
}
toc()
```

