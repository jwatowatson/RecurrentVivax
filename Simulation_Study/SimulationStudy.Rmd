---
title: "Simulation study to test vivax genetic relatedness model"
output:
  pdf_document: default
  html_document:
    df_print: paged
    keep_md: yes
---

Reviewer's example: "a recurrence with MOI of 3, containing a clone and two unrelated strains, but with overall pairwise relatedness close to 0.5.""

```{r, echo=FALSE, include=F}
knitr::opts_chunk$set(cache = TRUE, cache.comments = FALSE, 
                      echo = TRUE, include = TRUE, 
                      fig.width = 7, fig.height = 7,
                      fig.pos = 'H', 
                      dev = 'png', dpi = 300)

rm(list = ls())
load('../RData/RPackages_List.RData')
new.pkg <- pkgs[!(pkgs %in% installed.packages()[, "Package"])]
if(length(new.pkg) > 0){ # Install using .R script
  stop('Please run the script Install_and_load_required_packages.R before returning to this script. Thanks.')}else{
    sapply(pkgs, require, character.only = TRUE) # Load all packages
  }
tic()
```

```{r, echo=FALSE}
source('../Genetic_Model/iGraph_functions.R')
source('../Genetic_Model/Likelihood_function.R')
source('../Genetic_Model/Data_functions.R')
source('../Genetic_Model/test_Rn_compatible.R')
source('../Genetic_Model/post_prob_CLI.R')
source('BuildSimData.R')
```


Determines whether to run the full suite of simulations (takes a long time to run).
```{r}
RUN_MODELS = T
PLOT_RESULTS = T
```

## Simulation 1: Effective Complexity of Infection

We want to assess recurrence state inference as a function of the number of markers typed, adding extra noisy parasites into an infections with COI > 1. Note that when we previously specified a number a cut off for the number of heterolallelic calls (K_poly_markers < M), we unwittingly amplify evidence for relapse: 

* when `M <= K_poly_markers` the noisy parasite will be a stranger in relation to the other parasites in the same infection 
* when `K_poly_markers approx 0.5*M` the noisy parasite will be more like a sibling of the other parasites in the same infection. 
* when `K_poly_markers << M`, the noisy will approach a clone of the other parasites in the same infection, but will be considered a sibling under the model

Outline of simulation is as follows:

* Simulate data for N individuals, with M markers which are polyallelic for a given number K (this controls complexity of problem). We do this for two episodes where there are underlying clonal sibling and stranger relationships between episodes.
* Compute resulting recurrence state estimates
* Plot resulting recurrence state estimates as a function of the problem complexity, and the effective COI

```{r}
# Setup simulation study parameters
set.seed(1)
Cardinalities = c(4,13) # Marker cardinalities (set to match min and mean of our panel)
K_indivs = 10 # 1000 # Number of individuals
Ms = seq(3,12,3) # Number of MS markers
K_poly_markers = 9 # Number of polyallelic markers 
COIs_1 = c(1,3) # Maximum COI of primary episode 
COIs_2 = c(1,3) # Maximum COI of recurrent episode
COI_c_max = 6 # Maximum COI summed over infections that is computationally feasible
Related_types = c('Sibling','Stranger','Clone')

# Enumerate all combinations of COI complexity and numbers of markers
settings = expand.grid(Ms, COIs_1, COIs_2) # Enumerate all possible combinations of COIs and markers 
names(settings)= c('M','COI_1','COI_2') # Name colunms 
settings = settings[settings$COI_1+settings$COI_2<COI_c_max,] # Remove any with cumulative COI greater than that feasible
settings$COI_pattern <- paste(settings$COI_1, settings$COI_2, sep = "_") # Store the COIs as a patter
jobs = nrow(settings) # Number of simulations jobs
```

```{r}
RUN_MODELS = T
cardinality = 4 
related_type = 'Sibling'
job = 1 

# All simulation parameter settings possible
if(RUN_MODELS){
  for(cardinality in Cardinalities){ # iterate over cardinality of markers
    for(related_type in Related_types){ # iterative over simulation scenario 
      
      thetas_all = foreach(job = 1:jobs, .combine = rbind, # iterate over jobs parameter settings
                           .packages = c('dplyr','Matrix','gtools','igraph','matrixStats','doParallel')
      ) %do% { # parallisation happening inside the function
        
        COI_1 = settings$COI_1[job] # COI of primary infection
        COI_2 = settings$COI_2[job] # COI of recurrent infection
        M = settings$M[job] # Number of markers
        
        #####################################################
        # Simulate and save MS data
        #####################################################
        sim_output = BuildSimData(COIs = c(COI_1, COI_2), 
                                  M = M, 
                                  N = K_indivs,
                                  N_alleles = cardinality, 
                                  K_poly_markers = M, 
                                  relatedness = related_type)
        MS_data = sim_output$MS_data_sim
        
        # Save a copy of the simulated data
        save(MS_data, file=sprintf('SimulationOutputs/MS_Data_Cardinality%s_M%s_COIs%s_%s.RData', 
                                   cardinality, M, settings$COI_pattern[job], related_type))
        
        ######################################################################
        # Run the model on the data using default uniform prior over states
        ######################################################################
        TH = post_prob_CLI(MSdata = MS_data, cores = 7, Fs = sim_output$FS, verbose = F)
        TH$setting = job # Add setting number for plotting
        TH # return results
      }
      writeLines(paste0('********** Done for ', related_type,' **********'))
      fname = paste0('SimulationOutputs/Posterior_Probs_N*=',
                     cardinality,'_',
                     related_type,'_EffectCOI.RData')
      #save(thetas_all, file = fname)
    }
  }
}
```



### Plot results

```{r results_COI_effect, fig.width = 12, fig.height = 5}
States = c("C","I","L")
if(PLOT_RESULTS){
  
  # Alternative vizualisation: show one row in main plot
  State_names = list(L='Relapse',I='Reinfection',C='Recrudescence')
  mycols = brewer.pal(length(State_names), 'Dark2')
  related_type_names = c('Clone' = 'Clonal scenario', 
                         'Sibling' = 'Sibling scenario',
                         'Stranger' = 'Stranger scenario')
  
  par(mfrow = c(1,3), family = 'serif', pty = 's', oma = c(0,0,3,0), las =1, mar=c(4,5,4,1))
  BESIDES = T # Allows visualisation of error by stacking bars side by side
  
  
  for(pattern in unique(settings$COI_pattern)){
    JOBS_pattern <- which(settings$COI_pattern == as.character(pattern))
    for(cardinality in Cardinalities){ # Cardinalities
      
      # Iterate over simulation scenarions (types of data)
      for(related_type in names(related_type_names)){
        
        # Load data 
        fname = load(paste0('SimulationOutputs/Posterior_Probs_N*=',cardinality,'_',
                            related_type,'_EffectCOI.RData'))
        
        # Extract medians
        X <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, median)
        })
        
        # Extract standard deviations
        sds <- sapply(JOBS_pattern, function(x){
          ind <- thetas_all$setting == x
          apply(thetas_all[ind,States], 2, sd)
        })
        
        colnames(X) = settings[JOBS_pattern,'M']
        
        # Barplot
        Z = barplot(X, beside = BESIDES, col = mycols[1:3], ylim = c(0,1), 
                    ylab = '', xlab = '', cex.names=1.5,cex.axis = 1.5,
                    main = related_type_names[related_type])
        mtext(text = 'Probability', side = 2, line=3.5, cex=1, las=3)
        mtext(text = 'Number of markers', side = 1, line=3, cex=1.3)
        if(related_type=='Clone'){
          legend(ifelse(BESIDES,'topleft','top'), fill = mycols[1:3], 
                 legend = State_names[States], inset = 0.01,cex = 1.3)
        }
        
        # Title
        mtext(text = sprintf('Marker cardinality: %s \n COI of first and second infection: %s and %s, respectively', 
                             cardinality, strsplit(pattern, split = '_')[[1]][1], 
                             strsplit(pattern, split = '_')[[1]][1]), side = 3, outer = T)
        
        # Add error bars (+/- sd)
        if(BESIDES){
          rownames(Z) <- States
          for(state in States){
            segments(x0 = Z[state,], x1 = Z[state,], 
                     y0 = X[state,] - sds[state,], y1 = X[state,] + sds[state,])
          }
        }
      }
    }
  }
}

toc()
```

